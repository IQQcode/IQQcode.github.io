(window.webpackJsonp=window.webpackJsonp||[]).push([[408],{734:function(_,v,t){"use strict";t.r(v);var e=t(3),r=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("blockquote",[v("p",[v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP-传输控制协议"),v("OutboundLink")],1)])]),_._v(" "),v("h2",{attrs:{id:"_0-tcp协议的认识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0-tcp协议的认识"}},[_._v("#")]),_._v(" 0. TCP协议的认识")]),_._v(" "),v("blockquote",[v("p",[_._v("什么是 TCP 连接？")])]),_._v(" "),v("p",[v("strong",[_._v("用于保证 可靠性 和 流量控制 维护的某些-状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626192725.png",alt:"aa"}})]),_._v(" "),v("p",[_._v("所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Socket")]),_._v("：由 IP 地址和端口号组成")]),_._v(" "),v("li",[v("strong",[_._v("序列号")]),_._v("：用来解决乱序问题等")]),_._v(" "),v("li",[v("strong",[_._v("窗口大小")]),_._v("：用来做流量控制")])]),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"_1-tcp协议特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp协议特点"}},[_._v("#")]),_._v(" 1. TCP协议特点")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("面向连接")]),_._v("（虚连接）")]),_._v(" "),v("li",[v("strong",[_._v("点对点传输")]),_._v("。每一条TCP连接只能有两个端点，无法进行广播或多播")]),_._v(" "),v("li",[v("strong",[_._v("可靠有序，不丢不重")]),_._v("。TCP提供可靠的交付服务。无差错，不丢失，不重复，按序到达")]),_._v(" "),v("li",[v("strong",[_._v("全双工通信")])]),_._v(" "),v("li",[v("strong",[_._v("面向字节流")])])]),_._v(" "),v("p",[v("strong",[_._v("【面向连接】")]),_._v("：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；")]),_._v(" "),v("p",[v("strong",[_._v("【可靠】")]),_._v("：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；")]),_._v(" "),v("p",[v("strong",[_._v("【字节流】")]),_._v("：TCP将数据看成仅仅是一 连串的无结构的字节流。消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃")]),_._v(" "),v("p",[v("strong",[_._v("【全双工通信】")]),_._v("：发送方和接收方可以同时发送数据，接收数据。协议两端都设有发送缓存，接收缓存")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_2-tcp报文首部格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp报文首部格式"}},[_._v("#")]),_._v(" 2. TCP报文首部格式")]),_._v(" "),v("p",[v("code",[_._v("20B")]),_._v("的"),v("strong",[_._v("固定首部")]),_._v(" + 选项字段，"),v("strong",[_._v("4B对齐")]),_._v("方式")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200726174304.png",alt:""}})]),_._v(" "),v("p",[_._v("【源端口】：发送方端口，"),v("code",[_._v("16位")])]),_._v(" "),v("p",[_._v("【目的端口】：接收方端口，"),v("code",[_._v("16位")])]),_._v(" "),v("p",[_._v("【序号】："),v("u",[_._v("本报文段")]),_._v("所发送的数据-的"),v("font",{attrs:{color:"red"}},[_._v("第一个字节的序号")])],1),_._v(" "),v("p",[_._v("【确认号】："),v("font",{attrs:{color:"red"}},[_._v("期望")]),_._v("收到下一个报文段数据的"),v("font",{attrs:{color:"red"}},[_._v("第一个字节的序号")])],1),_._v(" "),v("p",[_._v("【数据偏移】：TCP首部长度，最大长度为(2^4^ - 1) * 4B = "),v("code",[_._v("60B")]),_._v("，固定首部"),v("code",[_._v("20B")]),_._v(" + 可变头部"),v("code",[_._v("40B")]),_._v("。由于首部长度不固定，所以数据起始位置不固定")]),_._v(" "),v("p",[_._v("【"),v("mark",[_._v("六个控制位")]),_._v("】")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("紧急位"),v("code",[_._v("URG")]),_._v("："),v("u",[_._v("发送方紧急处理位")]),_._v("。"),v("code",[_._v("URG=1")]),_._v("表示此段报文有紧急数据，要立即发送出去，不用在缓存队列中排队，配合"),v("u",[_._v("紧急指针")]),v("strong",[_._v("插队优先处理")])])]),_._v(" "),v("li",[v("p",[_._v("确认位"),v("code",[_._v("ACK")]),_._v("："),v("code",[_._v("ACK=1")]),_._v("，确认号有效")])]),_._v(" "),v("li",[v("p",[_._v("推送位"),v("code",[_._v("PSH")]),_._v("："),v("u",[_._v("接收方紧急处理位")]),_._v("。"),v("code",[_._v("PSH=1")]),_._v("时，接收方尽快向应用进程交付此段报文，不必等缓存队列填满")])]),_._v(" "),v("li",[v("p",[_._v("复位"),v("code",[_._v("RST")]),_._v("："),v("code",[_._v("RST=1")]),_._v("时，表示TCP与主机的连接"),v("strong",[_._v("出现严重差错")]),_._v("，必须释放连接再重新建立")])]),_._v(" "),v("li",[v("p",[_._v("同步位"),v("code",[_._v("SYN")]),_._v("："),v("code",[_._v("SYN=1")]),_._v("，表明一个连接 "),v("strong",[_._v("请求/连接")]),_._v("接收报文")])]),_._v(" "),v("li",[v("p",[_._v("终止位"),v("code",[_._v("FIN")]),_._v("："),v("code",[_._v("FIN=1")]),_._v("，表明发送方数据已发完，要求释放连接")])])]),_._v(" "),v("p",[_._v("【窗口】："),v("u",[_._v("接收方接收窗口的大小")]),_._v("，即现在允许发送方发送的数据量，根据接收方的窗口大小，设置发送方的发送缓存")]),_._v(" "),v("p",[_._v("【检验和】："),v("strong",[_._v("检验首部 + 数据")]),_._v("，检验时要加上"),v("code",[_._v("12B")]),_._v("伪首部「伪IP数据报首部」；第四个字段为协议字段，TCP为"),v("code",[_._v("6")]),_._v("，UDP为"),v("code",[_._v("17")])]),_._v(" "),v("p",[_._v("【紧急指针】："),v("code",[_._v("URG=1")]),_._v("时才有意义，指出本报文段中紧急数据的位置")]),_._v(" "),v("p",[_._v("【选项】：最大报文段长度MSS、窗口扩大、时间戳、选择确认")]),_._v(" "),v("p",[_._v("【填充】：填充0保证4字节对齐")]),_._v(" "),v("h3",{attrs:{id:"序号-确认号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#序号-确认号"}},[_._v("#")]),_._v(" 序号&确认号")]),_._v(" "),v("p",[v("strong",[_._v("序号：")]),v("u",[_._v("本报文段")]),_._v("所发送的数据-的"),v("font",{attrs:{color:"red"}},[_._v("第一个字节的序号")])],1),_._v(" "),v("p",[v("strong",[_._v("确认号")]),_._v("：确认上一次发送的成功收到。"),v("font",{attrs:{color:"red"}},[_._v("期望")]),_._v("收到下一个报文段数据的"),v("font",{attrs:{color:"red"}},[_._v("第一个字节的序号")])],1),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200727100928.png",alt:""}})]),_._v(" "),v("p",[_._v("序号的初始值是在建立连接后，"),v("strong",[_._v("随机生成的")])]),_._v(" "),v("h3",{attrs:{id:"urg-psh"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#urg-psh"}},[_._v("#")]),_._v(" URG&PSH")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("紧急位"),v("code",[_._v("URG")]),_._v("："),v("u",[_._v("发送方紧急处理位")]),_._v("。"),v("code",[_._v("URG=1")]),_._v("表示此段报文有紧急数据，要立即发送出去，不用在缓存队列中排队，配合"),v("u",[_._v("紧急指针")]),v("strong",[_._v("插队优先处理")])])]),_._v(" "),v("li",[v("p",[_._v("推送位"),v("code",[_._v("PSH")]),_._v("："),v("u",[_._v("接收方紧急处理位")]),_._v("。"),v("code",[_._v("PSH=1")]),_._v("时，接收方尽快向应用进程交付此段报文，不必等缓存队列填满")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200809090220.png",alt:""}})]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_3-三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-三次握手"}},[_._v("#")]),_._v(" 3. 三次握手")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200727162741.png",alt:""}})]),_._v(" "),v("center",[_._v("三次握手")]),_._v(" "),v("p",[v("strong",[_._v("【握手阶段】")])]),_._v(" "),v("ol",[v("li",[_._v("建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 "),v("font",{attrs:{color:"red"}},[_._v("LISTEN")]),_._v(" 状态，这时 Client 端准备建立链接。在第一次消息发送中，Client随机选取一个序列号作为自己的初始序号发送给Server，Client 端的链接状态变成了 "),v("font",{attrs:{color:"red"}},[_._v("SYN_SENT")]),_._v(" 状态；")],1),_._v(" "),v("li",[v("strong",[_._v("Server收到了来自Client的连接请求，如果在资源条件合理的情况下，服务器为该TCP连接分配缓存和变量")]),_._v("。Server使用ACK对Client的数据包进行确认，因为已经收到了序列号为"),v("code",[_._v("x")]),_._v("的数据包，准备接收序列号为 "),v("code",[_._v("x+1")]),_._v(" 的包，所以 "),v("code",[_._v("ack=x+1")]),_._v("，同时Server告诉Client自己的初始序列号，就是"),v("code",[_._v("seq=y")]),_._v("；发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 "),v("font",{attrs:{color:"red"}},[_._v("SYN_RCVD")])],1),_._v(" "),v("li",[_._v("Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了  "),v("font",{attrs:{color:"red"}},[_._v("ESTABLISHED")]),_._v(" 状态。同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。Client回复 "),v("code",[_._v("seq=x+1")]),_._v("、"),v("code",[_._v("ack=y+1")]),_._v(" ，"),v("u",[_._v("Client为该TCP连接分配缓存和变量")])],1)]),_._v(" "),v("h2",{attrs:{id:"_4-四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-四次挥手"}},[_._v("#")]),_._v(" 4. 四次挥手")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200727162558.png",alt:""}})]),_._v(" "),v("center",[_._v("四次挥手")]),_._v(" "),v("p",[v("strong",[_._v("【挥手阶段】")])]),_._v(" "),v("ol",[v("li",[_._v("Client准备关闭连接，首先主动向Server发送一个 TCP 首部 "),v("code",[_._v("FIN")]),_._v(" 标志位被置为 "),v("code",[_._v("1")]),_._v(" 的报文，Client随机选取一个序列号"),v("code",[_._v("seq=u")]),_._v("作为自己的初始序号发送给Server，之后客户端进入 "),v("font",{attrs:{color:"red"}},[_._v("FIN_WAIT_1")]),_._v(" 状态。")],1),_._v(" "),v("li",[_._v("Server回应"),v("code",[_._v("ACK")]),_._v("对Client的数据包进行确认，回复确认号"),v("code",[_._v("ack=u+1")]),_._v("，同时Server告诉Client自己的初始序列号"),v("code",[_._v("seq=v")]),_._v("；"),v("u",[_._v("客户到服务器这个方向的连接就成了一一半关闭 "),v("font",{attrs:{color:"red"}},[_._v("CLOSED_WAIT")]),_._v(" 状态")],1),_._v("。由于Server可能还与他客户端同时在通信，或者可能此时对A的数据没有发送完，此次不会回复"),v("code",[_._v("FIN")]),_._v("标志位。")]),_._v(" "),v("li",[_._v("第三条消息Server告诉Client可以断开连接，数据已传输完。回复"),v("code",[_._v("FIN=1")]),_._v("，"),v("code",[_._v("ACK=1")]),_._v("确认。Server依然回复第二次的确认号"),v("code",[_._v("ack=u+1")]),_._v("，因为这段时间Clinet处于半关闭状态，并没有在发送数据 。Server回复"),v("code",[_._v("seq=w")]),_._v("，进入 "),v("font",{attrs:{color:"red"}},[_._v("LAST_ACK")]),_._v("状态")],1),_._v(" "),v("li",[_._v("Clint收到Server的反馈后，回送"),v("code",[_._v("ACK=1")]),_._v("，由于要断开连接不再发送数据了，"),v("code",[_._v("seq=u+1")]),_._v("（序号为上次的ack），"),v("code",[_._v("ack=w+1")]),_._v("。发送完后Clinet进入 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("TIME_WAIT")])]),_._v("状态。Client在等待 "),v("strong",[_._v("2MSL")]),_._v(" 后，确保Server收到第四条消息后，自动进入 "),v("font",{attrs:{color:"red"}},[_._v("CLOSE")]),_._v("状态。Server收到第四条消息后进入了 "),v("font",{attrs:{color:"red"}},[_._v("CLOSE")]),_._v(" 状态。至此连接接关闭！")],1)]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"【三次握手即原因】"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#【三次握手即原因】"}},[_._v("#")]),_._v(" 【三次握手即原因】")]),_._v(" "),v("h3",{attrs:{id:"为什么是三次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么是三次"}},[_._v("#")]),_._v(" 为什么是三次")]),_._v(" "),v("p",[_._v("所以，重要的是"),v("strong",[_._v("为什么三次握手才可以初始化Socket、序列号和窗口大小，并建立 TCP 连接。")])]),_._v(" "),v("p",[_._v("以下原因：")]),_._v(" "),v("ol",[v("li",[_._v("三次握手才可以： "),v("strong",[_._v("阻止历史重复连接-的-初始化")]),_._v("（主要原因）")]),_._v(" "),v("li",[_._v("三次握手才可以： "),v("strong",[_._v("同步双方的初始序列号和序号")])]),_._v(" "),v("li",[_._v("三次握手才可以： "),v("strong",[_._v("避免资源浪费")])])]),_._v(" "),v("br"),_._v(" "),v("p",[v("strong",[_._v("不使用「两次握手」和「四次握手」的原因：")])]),_._v(" "),v("ul",[v("li",[_._v("「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；")]),_._v(" "),v("li",[_._v("「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。")])]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("br"),_._v(" "),v("h4",{attrs:{id:"原因一-避免历史连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因一-避免历史连接"}},[_._v("#")]),_._v(" 原因一：避免历史连接")]),_._v(" "),v("p",[_._v("我们来看看 RFC 793 指出的 TCP 连接使用三次握手的"),v("strong",[_._v("首要原因")]),_._v("：")]),_._v(" "),v("p",[v("em",[_._v("The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.")])]),_._v(" "),v("p",[_._v("三次握手的"),v("strong",[_._v("首要原因是为了防止旧的重复连接初始化造成混乱。")])]),_._v(" "),v("p",[_._v("网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？")]),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[v("strong",[_._v("三次握手避免历史连接")])])],1),_._v(" "),v("p",[_._v("客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：")]),_._v(" "),v("ul",[v("li",[_._v("一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；")]),_._v(" "),v("li",[_._v("那么此时服务端就会回一个 "),v("code",[_._v("SYN + ACK")]),_._v(" 报文给客户端；")]),_._v(" "),v("li",[_._v("客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 "),v("code",[_._v("RST")]),_._v(" 报文给服务端，表示中止这一次连接。")])]),_._v(" "),v("p",[_._v("如果是两次握手连接，就"),v("strong",[_._v("不能判断")]),_._v("当前连接是否是历史连接。")]),_._v(" "),v("br"),_._v(" "),v("p",[_._v("三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：")]),_._v(" "),v("ul",[v("li",[_._v("如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 "),v("code",[_._v("RST")]),_._v(" 报文，以此中止历史连接；")]),_._v(" "),v("li",[_._v("如果不是历史连接，则第三次发送的报文是 "),v("code",[_._v("ACK")]),_._v(" 报文，通信双方就会成功建立连接；")])]),_._v(" "),v("p",[_._v("所以， TCP 使用三次握手建立连接的最主要原因是"),v("strong",[_._v("防止历史连接初始化了连接。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626192751.png",alt:""}})]),_._v(" "),v("br"),_._v(" "),v("h4",{attrs:{id:"原因二-同步双方初始序列号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因二-同步双方初始序列号"}},[_._v("#")]),_._v(" 原因二：同步双方初始序列号")]),_._v(" "),v("p",[_._v("TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：")]),_._v(" "),v("ul",[v("li",[_._v("接收方可以去除重复的数据；")]),_._v(" "),v("li",[_._v("接收方可以根据数据包的序列号按序接收；")]),_._v(" "),v("li",[_._v("可以标识发送出去的数据包中， 哪些是已经被对方收到的；")])]),_._v(" "),v("p",[_._v("可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 "),v("code",[_._v("SYN")]),_._v(" 报文的时候，需要服务端回一个 "),v("code",[_._v("ACK")]),_._v(" 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，"),v("strong",[_._v("这样一来一回，才能确保双方的初始序列号能被可靠的同步。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626192905.png",alt:"87"}})]),_._v(" "),v("center",[_._v("四次握手与三次握手")]),_._v(" "),v("p",[_._v("四次握手其实也能够可靠的同步双方的初始化序号，但由于"),v("strong",[_._v("第二步和第三步可以优化成一步")]),_._v("，所以就成了「三次握手」。")]),_._v(" "),v("br"),_._v(" "),v("h4",{attrs:{id:"原因三-避免资源浪费-冗余连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因三-避免资源浪费-冗余连接"}},[_._v("#")]),_._v(" 原因三：避免资源浪费(冗余连接)")]),_._v(" "),v("p",[_._v("如果只有「两次握手」，当客户端的 "),v("code",[_._v("SYN")]),_._v(" 请求连接在网络中阻塞，客户端没有接收到 "),v("code",[_._v("ACK")]),_._v(" 报文，就会重新发送 "),v("code",[_._v("SYN")]),_._v(" ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 "),v("code",[_._v("ACK")]),_._v(" 确认信号，所以每收到一个 "),v("code",[_._v("SYN")]),_._v(" 就只能先主动建立一个连接，这会造成什么情况呢？")]),_._v(" "),v("p",[_._v("如果客户端的 "),v("code",[_._v("SYN")]),_._v(" 阻塞了，重复发送多次 "),v("code",[_._v("SYN")]),_._v(" 报文，那么服务器在收到请求后就会"),v("strong",[_._v("建立多个冗余的无效链接，造成不必要的资源浪费。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193007.png",alt:"39551"}})]),_._v(" "),v("center",[_._v("两次握手会造成资源浪费")]),_._v(" "),v("p",[v("img",{attrs:{src:"7-2-1.TCP%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B.assets/1595817905055-86b42923-285c-4a43-a130-008add288542.gif",alt:"image.gif"}})]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("br"),_._v(" "),v("h3",{attrs:{id:"为什么不是两次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次"}},[_._v("#")]),_._v(" 为什么不是两次")]),_._v(" "),v("p",[v("strong",[_._v("1. 两次握手会造成消息滞留")])]),_._v(" "),v("ul",[v("li",[_._v("服务器重复接受无用的连接请求 "),v("code",[_._v("SYN")]),_._v(" 报文，而造成重复分配资源")])]),_._v(" "),v("p",[v("strong",[_._v("2. 只能得知客户端具有发送的能力，不知道其是否有接收能力")])]),_._v(" "),v("ul",[v("li",[_._v("两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收")])]),_._v(" "),v("br"),_._v(" "),v("h3",{attrs:{id:"为什么不是四次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次"}},[_._v("#")]),_._v(" 为什么不是四次")]),_._v(" "),v("p",[_._v("三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。")]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"【四次挥手及原因】"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#【四次挥手及原因】"}},[_._v("#")]),_._v(" 【四次挥手及原因】")]),_._v(" "),v("h3",{attrs:{id:"为什么是四次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次"}},[_._v("#")]),_._v(" 为什么是四次")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("关闭连接时，客户端向服务端发送 "),v("code",[_._v("FIN")]),_._v(" 时，仅仅表示客户端不再发送数据了，"),v("font",{attrs:{color:"red"}},[_._v("但是还能接收数据")])],1)]),_._v(" "),v("li",[v("p",[_._v("服务器收到客户端的 "),v("code",[_._v("FIN")]),_._v(" 报文时，先回一个 "),v("code",[_._v("ACK")]),_._v(" 应答报文；而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 "),v("code",[_._v("FIN")]),_._v(" 报文给客户端来表示同意现在关闭连接。")])])]),_._v(" "),v("p",[_._v("服务端通常需要等待完成数据的发送和处理，所以服务端的 "),v("code",[_._v("ACK")]),_._v(" 和 "),v("code",[_._v("FIN")]),_._v(" 一般都会分开发送，从而比三次握手导致多了一次。")]),_._v(" "),v("br"),_._v(" "),v("h3",{attrs:{id:"为什么不是三次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是三次"}},[_._v("#")]),_._v(" 为什么不是三次")]),_._v(" "),v("p",[v("strong",[_._v("四次才能确保数据能够完成传输。")])]),_._v(" "),v("p",[_._v("关闭连接时，当服务器收到客户端的FIN报文通知时，它仅仅表示客户端没有数据发送给服务器了；但未必服务器所有的数据都全部发送给对方了")]),_._v(" "),v("p",[_._v("服务器不会关闭SOCKET，可能还需要发送一些数据给客户端之后，所以第二次只发送"),v("code",[_._v("ACK")]),_._v("确认报文，第三次再发送"),v("code",[_._v("FIN")]),_._v("报文给对方来表示同意现在可以关闭连接了")]),_._v(" "),v("p",[_._v("所以它"),v("code",[_._v("ACK")]),_._v("报文和"),v("code",[_._v("FIN")]),_._v("报文多数情况下都是分开发送的。")]),_._v(" "),v("br"),_._v(" "),v("p",[v("strong",[_._v("挥手的时候为什么是分开的时候发送呢?")])]),_._v(" "),v("ul",[v("li",[_._v("一起发送可能会导致一方被迫强制关闭")])]),_._v(" "),v("p",[_._v("因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。")]),_._v(" "),v("p",[_._v('但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。')]),_._v(" "),v("p",[_._v("如果服务器段将ACK(第二次挥手)和FIN(第三次挥手)合并成一块发过去的话，这就意味着一方关闭，另一方也要被迫关闭，若此时有服务器继续"),v("strong",[_._v("单向的发送片段")]),_._v("给客户端的需求则无法实现。")]),_._v(" "),v("p",[_._v("故需要四步"),v("strong",[_._v("挥手")]),_._v("。")]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"【time-wait-等待-2msl】"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#【time-wait-等待-2msl】"}},[_._v("#")]),_._v(" 【TIME_WAIT 等待 2MSL】")]),_._v(" "),v("blockquote",[v("p",[v("code",[_._v("MSL")]),_._v(" 是 Maximum Segment Lifetime，"),v("strong",[_._v("报文最大生存时间")]),_._v("，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。")])]),_._v(" "),v("p",[_._v("Client发送完第四次消息后，并不知道Server是否接收到了这次的消息，因为是可靠传输，但是挥手只是4次，它需要默默等待Server接收到消息后才下线。（🤔PS：真实负责的好男人呀！）")]),_._v(" "),v("p",[_._v("如果报文丢失了或者Server接收到错误的报文：")]),_._v(" "),v("ul",[v("li",[_._v("Server重复第三次挥手过程，让Client再重新发送一次")])]),_._v(" "),v("p",[_._v("TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：")]),_._v(" "),v("p",[_._v("网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以"),v("strong",[_._v("一来一回需要等待 2 倍的时间")]),_._v("。")]),_._v(" "),v("p",[_._v("比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。")]),_._v(" "),v("p",[v("code",[_._v("2MSL")]),_._v(" 的时间是从"),v("strong",[_._v("客户端接收到 FIN 后发送 ACK 开始计时的")]),_._v("。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 "),v("strong",[_._v("2MSL 时间将重新计时")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("等待2MSL是为了确认服务器能够收到第四次挥手消息")])]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"初始序列号isn的初始化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初始序列号isn的初始化"}},[_._v("#")]),_._v(" 初始序列号ISN的初始化")]),_._v(" "),v("blockquote",[v("p",[_._v("为什么客户端和服–务端的初始序列号 ISN 是不相同的？")])]),_._v(" "),v("p",[_._v("因为网络中的报文"),v("strong",[_._v("会延迟、会复制重发、也有可能丢失")]),_._v("，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。")]),_._v(" "),v("p",[_._v("ISN是不能硬编码的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://link.zhihu.com/?target=http%3A//tools.ietf.org/html/rfc793",target:"_blank",rel:"noopener noreferrer"}},[_._v("RFC793"),v("OutboundLink")],1),_._v("中说，"),v("strong",[_._v("ISN会和一个假的时钟绑在一起")]),_._v("，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32^，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过MSL（Maximum Segment Lifetime ），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。")]),_._v(" "),v("p",[_._v("这样做可以"),v("strong",[_._v("防止ISN重用")]),_._v("，另外出于安全考虑，也不应该对ISN硬编码。")]),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"syn洪泛攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#syn洪泛攻击"}},[_._v("#")]),_._v(" SYN洪泛攻击")]),_._v(" "),v("blockquote",[v("p",[_._v("https://zh.wikipedia.org/wiki/SYN_flood")])]),_._v(" "),v("p",[_._v("TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 "),v("code",[_._v("SYN")]),_._v(" 报文，服务端每接收到一个 "),v("code",[_._v("SYN")]),_._v(" 报文，就进入"),v("code",[_._v("SYN_RCVD")]),_._v(" 状态，但服务端发送出去的 "),v("code",[_._v("ACK + SYN")]),_._v(" 报文，无法得到未知 IP 主机的 "),v("code",[_._v("ACK")]),_._v(" 应答，久而久之就会"),v("strong",[_._v("占满服务端的 SYN 接收队列（未连接队列）")]),_._v("，消耗服务器资源，使得服务器不能为正常用户服务。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193044.png",alt:"SYN 攻击.png"}})]),_._v(" "),v("center",[_._v("SYN 攻击")]),_._v(" "),v("p",[v("img",{attrs:{src:"7-2-1.TCP%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B.assets/1595817904954-b9d6ff90-25fa-4332-814b-c3013dfb36be.gif",alt:"image.gif"}})]),_._v(" "),v("p",[_._v("SYN Flood是当前最流行的"),v("a",{attrs:{href:"https://baike.baidu.com/item/DoS",target:"_blank",rel:"noopener noreferrer"}},[_._v("DoS"),v("OutboundLink")],1),_._v("（拒绝服务攻击）与"),v("a",{attrs:{href:"https://baike.baidu.com/item/DDoS",target:"_blank",rel:"noopener noreferrer"}},[_._v("DDoS"),v("OutboundLink")],1),_._v("（Distributed Denial Of Service"),v("a",{attrs:{href:"https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB",target:"_blank",rel:"noopener noreferrer"}},[_._v("分布式拒绝服务攻击"),v("OutboundLink")],1),_._v("）的方式之一。")]),_._v(" "),v("p",[v("strong",[_._v("【解决方式】")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("缩短SYN Timeout时间")])]),_._v(" "),v("li",[v("strong",[_._v("设置SYN Cookie")])]),_._v(" "),v("li",[v("strong",[_._v("SYN flood可以用DCN防火墙来拦截")])]),_._v(" "),v("li",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193053.png",alt:"image-20201102143958970"}})])]),_._v(" "),v("p",[v("u",[_._v("第一种：缩短SYN Timeout时间")])]),_._v(" "),v("p",[_._v("由于SYN Flood攻击的效果取决于服务器上保持的SYN半"),v("a",{attrs:{href:"https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=72259415&ss_c=ssc.citiao.link",target:"_blank",rel:"noopener noreferrer"}},[_._v("连接数"),v("OutboundLink")],1),_._v("，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃该连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。")]),_._v(" "),v("p",[v("u",[_._v("第二种方法：设置SYN Cookie")])]),_._v(" "),v("p",[_._v("就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被丢弃。")]),_._v(" "),v("p",[_._v("可是上述的两种方法只能对付比较原始的SYN Flood攻击")]),_._v(" "),v("p",[v("u",[_._v("第三种方法：DCN防火墙来拦截")])]),_._v(" "),v("p",[_._v("防火墙做一个中继，起到保护作用。")]),_._v(" "),v("ul",[v("li",[_._v("SYN网关")]),_._v(" "),v("li",[_._v("被动SYN网关")]),_._v(" "),v("li",[_._v("SYN中继")])]),_._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://blog.csdn.net/weixin_44953600/article/details/106670263",target:"_blank",rel:"noopener noreferrer"}},[_._v("防火墙如何阻止SYN Flood攻击"),v("OutboundLink")],1)])]),_._v(" "),v("p",[_._v("I. SYN网关")]),_._v(" "),v("p",[_._v("防火墙收到 服务端的 SYN/ACK 包后 ， 会立刻发送一个ACK包 给服务端，减少半连接数。（当客户端真正的ACK包到达时，有数据 则转发给服务端，没有数据则丢弃该包。）")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193102.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("II. 被动SYN网关")]),_._v(" "),v("p",[_._v("防火墙的超时期限远小于服务器的超时期限，当 超过 防火墙的期限后，客户端 还没有发送ACK包，防火墙就会向服务器发送RST包，节约了半连接时间。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193107.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("III. SYN中继")]),_._v(" "),v("p",[_._v("得先跟防火墙三次握手成功，才能和 服务端 进行连接。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193111.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("br"),_._v(" "),v("hr"),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"client-server状态变化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#client-server状态变化"}},[_._v("#")]),_._v(" Client-Server状态变化")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626193116.png",alt:"6400"}})]),_._v(" "),v("h3",{attrs:{id:"client"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[_._v("#")]),_._v(" Client")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("SYN_SENT")]),_._v(" - 客户端发起第 1 次握手后，连接状态为 SYN_SENT ，等待服务端内核进行应答，如果服务端来不及处理（例如服务端的 backlog 队列已满）就可以看到这种状态的连接。")]),_._v(" "),v("li",[v("code",[_._v("ESTABLISHED")]),_._v(" - 表示连接处于正常状态，可以进行数据传送。客户端收到服务器回复的 SYN+ACK 后，对服务端的 SYN 单独回复（第 3 次握手），连接建立完成，进入 ESTABLISHED 状态。服务端程序收到第 3 次握手包后，也进入 ESTABLISHED 状态。")]),_._v(" "),v("li",[v("code",[_._v("FIN_WAIT_1")]),_._v(" - 客户端发送了关闭连接的 FIN 报文后，等待服务端回复 ACK 确认。")]),_._v(" "),v("li",[v("code",[_._v("FIN_WAIT_2")]),_._v(" - 表示我方已关闭连接，正在等待服务端关闭。客户端发了关闭连接的 FIN 报文后，服务器发回 ACK 应答，但是没进行关闭，就会处于这种状态。")]),_._v(" "),v("li",[v("code",[_._v("TIME_WAIT")]),_._v(" - 双方都正常关闭连接后，客户端会维持 TIME_WAIT 一段时间，以确保最后一个 ACK 能成功发送到服务器端。停留时长为 2 倍的 MSL (报文最大生存时间)，Linux 下大约是 60 秒。所以在一个频繁建立短连接的服务器上通常可以看到成千上万的 TIME_WAIT 连接。")])]),_._v(" "),v("h3",{attrs:{id:"server"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[_._v("#")]),_._v(" Server")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("LISTEN")]),_._v(" - 表示当前程序正在监听某个端口时。")]),_._v(" "),v("li",[v("code",[_._v("SYN_RCVD")]),_._v(" - 服务端收到第 1 次握手后，进入 SYN_RCVD 状态，并回复一个 SYN+ACK（第 2 次握手），再等待对方确认。")]),_._v(" "),v("li",[v("code",[_._v("ESTABLISHED")]),_._v(" - 表示连接处于正常状态，可以进行数据传送。完成 TCP3 次握手后，连接建立完成，进入 ESTABLISHED 状态。")]),_._v(" "),v("li",[v("code",[_._v("CLOSE_WAIT")]),_._v(" - 表示客户端已经关闭连接，但是本地还没关闭，正在等待本地关闭。有时客户端程序已经退出了，但服务端程序由于异常或 BUG 没有调用 close()函数对连接进行关闭，那在服务器这个连接就会一直处于 CLOSE_WAIT 状态，而在客户机已经不存在这个连接了。")]),_._v(" "),v("li",[v("code",[_._v("LAST_ACK")]),_._v(" - 表示正在等待客户端对服务端的关闭请求进行最终确认。")])])],1)}),[],!1,null,null,null);v.default=r.exports}}]);