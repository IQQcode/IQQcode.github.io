(window.webpackJsonp=window.webpackJsonp||[]).push([[365],{688:function(_,v,t){"use strict";t.r(v);var r=t(3),e=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-b树与b-树的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-b树与b-树的区别"}},[_._v("#")]),_._v(" 1. B树与B+树的区别")]),_._v(" "),v("p",[_._v("B-树、B+树、红黑树都是平衡查找树，从查询效率上讲，平均都是O(log n)")]),_._v(" "),v("p",[v("strong",[_._v("【B树与B+树的本质区别】")])]),_._v(" "),v("ul",[v("li",[_._v("B树节点存放数据，B+树的所有数据存放在叶子节点")]),_._v(" "),v("li",[_._v("B+树叶子节点是双向链表，并且是有序的")])]),_._v(" "),v("h3",{attrs:{id:"叶子-非叶"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#叶子-非叶"}},[_._v("#")]),_._v(" 叶子-非叶")]),_._v(" "),v("p",[v("strong",[_._v("【叶子节点】")])]),_._v(" "),v("ul",[v("li",[_._v("InnoDB：主键ID对应的行数据记录")]),_._v(" "),v("li",[_._v("MyISAM：存储指向数据行的指针，可以直接取得全部的数据行数据")])]),_._v(" "),v("p",[v("strong",[_._v("【非叶子节点】")])]),_._v(" "),v("ul",[v("li",[v("font",{attrs:{color:"#1e90ff"}},[v("strong",[_._v("非叶子节点不保存数据，只保存子树的"),v("code",[_._v("key")]),_._v("的临界值（最大或者最小）")])]),_._v("。非叶子节点相当于是叶子节点的索引（稀疏索引），存储的是数据索引范围的临界值，所有的非叶子节点都可以看成是索引部分")],1)]),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"_2-b-树的优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-b-树的优势"}},[_._v("#")]),_._v(" 2. B+树的优势")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("B+树能够显著降低磁盘IO，使非叶节点的每一页能够存放更多的索引数据")]),_._v("。由于B+树在"),v("strong",[_._v("非叶子结点上不包含真正的数据")]),_._v("，"),v("strong",[_._v("只当做索引使用")]),_._v("，因此在内存相同的情况下，能够存放更多的"),v("code",[_._v("key")]),_._v("，所以每一层能够包含更多的节点因子，树高更矮。")]),_._v(" "),v("li",[v("strong",[_._v("B+树的叶子结点都是相连且有序的，叶子节点间维护了双向链表，方便范围查找")]),_._v("。因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历")]),_._v(" "),v("li",[v("strong",[_._v("更稳定的查询效率")]),_._v("。B+树是绝对平衡的数，时间复杂度为"),v("code",[_._v("O(logn)")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232211.jpg",alt:"640"}})]),_._v(" "),v("h3",{attrs:{id:"降低磁盘io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#降低磁盘io"}},[_._v("#")]),_._v(" 降低磁盘IO")]),_._v(" "),v("p",[v("strong",[_._v("从磁盘中读取数据时，都是按照磁盘页来读取的，并不是一条一条的读。")]),_._v(" 如果我们能把尽量多的数据放进磁盘页中，那一次IO读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。")]),_._v(" "),v("p",[_._v("关系数据库这种数据量大索引能达到亿级别，为了减少内存的占用，索引也会被存储在磁盘上。B-树/B+树的特点就是"),v("strong",[_._v("每层节点数目非常多，层数少，目的就是为了减少磁盘的IO次数")]),_._v("。")]),_._v(" "),v("p",[_._v("但是B-树的每个节点都有"),v("code",[_._v("data")]),_._v("域（指针），这无疑是增大了节点大小，也增加了磁盘的IO次数（因为磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就会减少，IO次数也会增多），而"),v("strong",[_._v("B+树除了叶子节点其他节点并不存储数据，节点小，磁盘IO次数就少")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"范围查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#范围查找"}},[_._v("#")]),_._v(" 范围查找")]),_._v(" "),v("p",[_._v("B+树所有的"),v("code",[_._v("Data")]),_._v("域在叶子节点，B+树中各个页之间是通过"),v("strong",[_._v("双向链表")]),_._v("连接的，叶子节点中的数据是通过"),v("strong",[_._v("单向链表")]),_._v("连接的。这样遍历叶子节点就能获得全部数据，这样就能进行"),v("strong",[_._v("区间访问")]),_._v("了。在数据库中基于范围的查询时非常频繁的，而B树不支持这样的遍历操作。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_3-举例计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-举例计算"}},[_._v("#")]),_._v(" 3. 举例计算")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("p")]),_._v("指针存放的是磁盘文件的地址")])]),_._v(" "),v("p",[_._v("InnoDB每一页大小为"),v("code",[_._v("16kb")]),_._v("，存取的主键字段"),v("code",[_._v("int")]),_._v("大小为"),v("code",[_._v("4B")]),_._v("，磁盘文件地址指针"),v("code",[_._v("p")]),_._v("大小为"),v("code",[_._v("6B")]),_._v("，当前B+树高为3，且叶子节点全部放满：")]),_._v(" "),v("ul",[v("li",[_._v("第一层存放"),v("code",[_._v("16kb / (6 + 4B)")]),_._v(" = "),v("strong",[_._v("1638")]),_._v("个index")]),_._v(" "),v("li",[_._v("第二层存放"),v("strong",[_._v("1638")]),_._v("个index")]),_._v(" "),v("li",[_._v("第三层为"),v("code",[_._v("16kb")]),_._v("的"),v("strong",[_._v("data")])])]),_._v(" "),v("p",[_._v("共计存放"),v("code",[_._v("1638 * 1638 * 16")]),_._v("= "),v("strong",[_._v("4000万")]),_._v(" 条主键索引数据")]),_._v(" "),v("p",[_._v("一般"),v("strong",[_._v("根节点是常驻内存")]),_._v("的，所以一般我们查找10亿数据，只需要2次磁盘IO。")]),_._v(" "),v("br"),_._v(" "),v("br"),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"附录说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#附录说明"}},[_._v("#")]),_._v(" 附录说明")]),_._v(" "),v("p",[_._v("B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("每个结点最多有M-1个key，并且以升序排列；")])]),_._v(" "),v("li",[v("p",[_._v("每个结点最多能有M个子结点；")])]),_._v(" "),v("li",[v("p",[_._v("根结点至少有两个子结点；")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232319.png",alt:"image-20200823070706890"}})]),_._v(" "),v("h3",{attrs:{id:"b树的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b树的优点"}},[_._v("#")]),_._v(" B树的优点")]),_._v(" "),v("p",[_._v("由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。")]),_._v(" "),v("h3",{attrs:{id:"b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[_._v("#")]),_._v(" B+树")]),_._v(" "),v("p",[_._v("B+树是对B树的一种变形树，它与B树的差异在于：")]),_._v(" "),v("ol",[v("li",[_._v("非叶结点仅具有–索引作用，也就是说，"),v("strong",[_._v("非叶子结点只存储key，不存储value")]),_._v("；")]),_._v(" "),v("li",[_._v("树的所有叶结点构成一个"),v("strong",[_._v("有序链表")]),_._v("，可以按照key排序的次序遍历全部数据。")])]),_._v(" "),v("h3",{attrs:{id:"b-树存储数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树存储数据"}},[_._v("#")]),_._v(" B+树存储数据")]),_._v(" "),v("p",[_._v("若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232414.png",alt:"image-20200816154755778"}})]),_._v(" "),v("h3",{attrs:{id:"未建立主键索引查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#未建立主键索引查询"}},[_._v("#")]),_._v(" 未建立主键索引查询")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232419.png",alt:"image-20200816154924284"}})]),_._v(" "),v("p",[_._v("执行"),v("code",[_._v("select * from user where id=18")]),_._v(",需要从第一条数据开始，一直查询到第6条，发现id=18，此时才能查询出目标结果，共需要比较6次；")]),_._v(" "),v("p",[_._v("执行"),v("code",[_._v("select * from user where id = 18")]),_._v(" ，如果有了索引，由于B+树的叶子结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("18 > 12")]),_._v("，在"),v("code",[_._v("12")]),_._v("节点的右孩子")]),_._v(" "),v("li",[_._v("遍历右孩子链表，根据"),v("code",[_._v("key=18")]),_._v("，找到其地址即可")])]),_._v(" "),v("p",[_._v("按照遍历链表的方式顺序往后查即可，共查询了3次，效率非常高。")]),_._v(" "),v("p",[v("strong",[_._v("在区间查询时，效率体现的更加明显")])]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("【参考文章】")]),_._v(" "),v("p",[_._v("[1] "),v("a",{attrs:{href:"https://www.cnblogs.com/gekh/p/9965444.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("B-Tree和 B+Tree的数据存储结构"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("[2] "),v("a",{attrs:{href:"http://www.gxlcms.com/mysql-366759.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("MySQL为什么选择B+树作为索引结构"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("[3] "),v("a",{attrs:{href:"https://blog.csdn.net/Alice_8899/article/details/105357902",target:"_blank",rel:"noopener noreferrer"}},[_._v("B+树叶子结点到底存储了什么"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("[4] "),v("a",{attrs:{href:"https://blog.csdn.net/xdzhouxin/article/details/80015424",target:"_blank",rel:"noopener noreferrer"}},[_._v("数据结构之B-树、B+树"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);