(window.webpackJsonp=window.webpackJsonp||[]).push([[367],{690:function(t,_,v){"use strict";v.r(_);var r=v(3),a=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1-索引使用注意事项"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引使用注意事项"}},[t._v("#")]),t._v(" 1. 索引使用注意事项")]),t._v(" "),_("h3",{attrs:{id:"定义索引的类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定义索引的类型"}},[t._v("#")]),t._v(" 定义索引的类型")]),t._v(" "),_("p",[_("font",{attrs:{color:"#f51f54"}},[_("strong",[t._v("主键通常建议使用auto_increment自增int类型")])]),t._v("。"),_("strong",[t._v("保证聚簇索引的数据的物理存放顺序与索引顺序是一致的，当-当前页被插满后，继续插入到新的页上")])],1),t._v(" "),_("h3",{attrs:{id:"为什么用自增"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么用自增"}},[t._v("#")]),t._v(" 为什么用自增")]),t._v(" "),_("p",[_("strong",[t._v("保证聚簇索引的数据的物理存放顺序与索引顺序是一致的")])]),t._v(" "),_("p",[t._v("①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费")]),t._v(" "),_("p",[t._v("②新插入的行一定会在原有的最大数据行下一行，mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗")]),t._v(" "),_("p",[t._v("③减少了页分裂和碎片的产生")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，它会不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。")]),t._v(" "),_("p",[t._v("但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。")]),t._v(" "),_("p",[t._v("因为"),_("strong",[t._v("MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转")]),t._v("。"),_("strong",[t._v("聚簇索引则只需一次I/O")]),t._v("。（强烈的对比）")]),t._v(" "),_("h3",{attrs:{id:"为什么用int"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么用int"}},[t._v("#")]),t._v(" 为什么用int")]),t._v(" "),_("p",[t._v("自增的"),_("code",[t._v("int")]),t._v(" id，避免了 "),_("strong",[t._v("索引的调整维护，当-当前页被插满后，继续插入到新的页上")])]),t._v(" "),_("p",[t._v("因为uuid相对顺序的自增id来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以innodb无法做到总是把新行插入到索引的最后,而是需要为新行寻找新的合适的位置从而来分配新的空间。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232539.png",alt:"img"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232542.png",alt:"img"}})]),t._v(" "),_("p",[t._v("不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。")]),t._v(" "),_("h3",{attrs:{id:"不推荐使用uuid或者雪花id作为主键"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不推荐使用uuid或者雪花id作为主键"}},[t._v("#")]),t._v(" 不推荐使用uuid或者雪花id作为主键")]),t._v(" "),_("p",[t._v("①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO")]),t._v(" "),_("p",[t._v("②因为写入是乱序的,innodb不得不频繁的做页分裂操作,以便为新的行分配空间,页分裂导致移动大量的数据，一次插入最少需要修改三个页以上")]),t._v(" "),_("p",[t._v("③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片")]),t._v(" "),_("h2",{attrs:{id:"_2-索引什么时候用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-索引什么时候用"}},[t._v("#")]),t._v(" 2. 索引什么时候用")]),t._v(" "),_("h3",{attrs:{id:"需要索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#需要索引"}},[t._v("#")]),t._v(" 需要索引")]),t._v(" "),_("ol",[_("li",[t._v("主键，唯一索引")]),t._v(" "),_("li",[t._v("经常用作查询条件的字段需要创建索引")]),t._v(" "),_("li",[t._v("经常需要排序、分组和统计的字段需要建立索引")]),t._v(" "),_("li",[t._v("查询中与其他表关联的字段，外键关系建立索引")])]),t._v(" "),_("h3",{attrs:{id:"不需要建索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不需要建索引"}},[t._v("#")]),t._v(" 不需要建索引")]),t._v(" "),_("ol",[_("li",[t._v("表的记录太少，百万级以下的数据不需要创建索引")]),t._v(" "),_("li",[t._v("经常增删改的表不需要创建索引")]),t._v(" "),_("li",[t._v("数据"),_("strong",[t._v("重复且分布平均")]),t._v("的字段不需要创建索引，如 true,false 之类")]),t._v(" "),_("li",[t._v("频发更新的字段不适合创建索引")]),t._v(" "),_("li",[t._v("where条件里"),_("strong",[t._v("用不到")]),t._v("的字段不需要创建索引")])]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("【参考】")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/wyq178/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Yrion-深入分析mysql为什么不推荐使用uuid或者雪花id作为主键"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/itdragon/p/8146439.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL索引优化分析"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);