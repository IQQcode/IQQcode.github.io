(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{515:function(t,a,s){"use strict";s.r(a);var e=s(3),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-reentrantlock和aqs的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-reentrantlock和aqs的关系"}},[t._v("#")]),t._v(" 1. ReentrantLock和AQS的关系")]),t._v(" "),a("p",[t._v("Lock的使用：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Lock")]),t._v(" lock "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 加锁")]),t._v("\nlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 线程任务")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁")]),t._v("\n    lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("p",[a("code",[t._v("ReentrantLock")]),t._v("、"),a("code",[t._v("ReentrantReadWriteLock")]),t._v("底层，是基于"),a("strong",[t._v("AQS")]),t._v("来实现的")]),t._v(" "),a("p",[a("strong",[t._v("AQS")]),t._v("（AbstractQueuedSynchronizer），抽象队列同步器。"),a("code",[t._v("ReentrantLock")]),t._v("内部包含了AQS对象，AQS是"),a("code",[t._v("ReentrantLock")]),t._v("实现加锁和释放锁的关键核心组件")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203023.png",alt:"image-20201002155731816"}})]),t._v(" "),a("p",[a("strong",[t._v("AQS 队列同步器 三要素 ：")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("CAS 通过此来竞争锁资源")])]),t._v(" "),a("li",[a("strong",[t._v("LockSurpport.park/unpark 线程阻塞和释放")])]),t._v(" "),a("li",[a("strong",[t._v("CLH 双向链表 存放被阻塞的线程")])])]),t._v(" "),a("h3",{attrs:{id:"aqs原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs原理"}},[t._v("#")]),t._v(" AQS原理")]),t._v(" "),a("p",[t._v("AQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包")]),t._v(" "),a("p",[a("strong",[t._v("AQS的核心思想：")])]),t._v(" "),a("p",[t._v("如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。")]),t._v(" "),a("p",[a("strong",[t._v("用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。")])]),t._v(" "),a("li",[a("p",[t._v("AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203027.png",alt:"img"}})]),t._v(" "),a("p",[t._v("AQS维护了一个"),a("strong",[t._v("volatile")]),t._v(" "),a("code",[t._v("int state")]),t._v("和一个"),a("strong",[t._v("FIFO")]),t._v("线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。")]),t._v(" "),a("p",[t._v("state就是共享资源，其访问方式有如下三种：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("getState()")])]),t._v(" "),a("li",[a("code",[t._v("setState()")])]),t._v(" "),a("li",[a("code",[t._v("compareAndSetState();")])])]),t._v(" "),a("p",[t._v("CLH队列--双向链表实现")]),t._v(" "),a("p",[t._v("🔗"),a("a",{attrs:{href:"https://blog.csdn.net/lzb348110175/article/details/103709548?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.channel_param",target:"_blank",rel:"noopener noreferrer"}},[t._v("AQS 同步器原理分析"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("AQS "),a("strong",[t._v("Node")]),t._v("节点被 "),a("code",[t._v("volatile")]),t._v(" 修饰，head 和 tail（即：链表的头部和尾部）")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Head of the wait queue, lazily initialized. ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Tail of the wait queue, lazily initialized. .")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" tail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203031.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋"),a("code",[t._v("while(!cas())")]),t._v("的方式，不停地尝试获取锁，直到被其他线程获取成功")]),t._v(" "),a("p",[a("strong",[t._v("实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物")])]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_2-reentrantlock锁机制原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-reentrantlock锁机制原理"}},[t._v("#")]),t._v(" 2. ReentrantLock锁机制原理")]),t._v(" "),a("p",[t._v("AQS内部核心")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("state")]),t._v(" int类型，初始为0。代表"),a("strong",[t._v("加锁的状态")])]),t._v(" "),a("li",[t._v("关键变量，记录当前获取到锁的线程，初值为null")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203036.png",alt:"image-20201002160516494"}})]),t._v(" "),a("p",[t._v("初始时，线程A调用"),a("strong",[t._v("RentrantLock")]),t._v("的"),a("code",[t._v("lock")]),t._v("方法尝试加锁，加锁的过程是用"),a("strong",[t._v("CAS")]),t._v("将"),a("code",[t._v("state")]),t._v("由0变为1")]),t._v(" "),a("p",[t._v("此时线程A获取锁成功")]),t._v(" "),a("p",[t._v("线程A加锁成功后，将加锁线程设置为"),a("strong",[t._v("自己")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203039.png",alt:"image-20201002163803922"}})]),t._v(" "),a("h3",{attrs:{id:"可重入锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁"}},[t._v("#")]),t._v(" 可重入锁")]),t._v(" "),a("p",[t._v("线程A再次获取到了锁，判断"),a("strong",[t._v("当前加锁线程是否是自己？")]),t._v("，是的话再次获取锁成功，"),a("code",[t._v("satte")]),t._v("类加1")]),t._v(" "),a("h3",{attrs:{id:"互斥锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[t._v("#")]),t._v(" 互斥锁")]),t._v(" "),a("p",[t._v("线程B想要获取锁，先判断"),a("code",[t._v("state")]),t._v("是否为0")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("state = 0")]),t._v("，尝试获取锁")]),t._v(" "),a("li",[a("code",[t._v("state != 0")]),t._v("，看持有锁的线程是否是自己；不是则进入到"),a("strong",[t._v("等待队列")])]),t._v(" "),a("li",[t._v("线程B等待线程A释放锁之后，尝试重新获取")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203043.png",alt:"image-20201002164533921"}})]),t._v(" "),a("p",[a("strong",[t._v("AQS中有一个等待队列，存放获取锁🔒失败的线程")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203047.png",alt:"image-20201002164601001"}})]),t._v(" "),a("h3",{attrs:{id:"释放锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#释放锁"}},[t._v("#")]),t._v(" 释放锁")]),t._v(" "),a("p",[a("code",[t._v("state")]),t._v("变量减一，为0时彻底释放锁，不再持有资源，"),a("strong",[t._v("直至 加锁线程为null")])]),t._v(" "),a("p",[t._v("接下来，"),a("strong",[t._v("从等待队列的对头唤醒线程B，重新尝试加锁")])]),t._v(" "),a("ul",[a("li",[t._v("线程B重复上述操作，获取锁成功")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210621203051.png",alt:"image-20201002165433895"}})]),t._v(" "),a("h2",{attrs:{id:"_3-aqs资源共享方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-aqs资源共享方式"}},[t._v("#")]),t._v(" 3. AQS资源共享方式")]),t._v(" "),a("p",[t._v("AQS 定义了两种资源共享方式：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("Exclusive")]),t._v("：独占，只有一个线程能执行，如ReentrantLock")]),t._v(" "),a("li",[a("strong",[t._v("Share")]),t._v("：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier")])]),t._v(" "),a("p",[t._v("不同的自定义的同步器争用共享资源的方式也不同")]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_4-aqs底层使用了模板方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-aqs底层使用了模板方法模式"}},[t._v("#")]),t._v(" 4. AQS底层使用了模板方法模式")]),t._v(" "),a("p",[t._v("同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：")]),t._v(" "),a("ol",[a("li",[t._v("使用者继承AbstractQueuedSynchronizer并重写指定的方法。")]),t._v(" "),a("li",[t._v("将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。")])]),t._v(" "),a("p",[a("strong",[t._v("自定义同步器")]),t._v("在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("isHeldExclusively()")]),t._v("：该线程是否正在独占资源。只有用到"),a("code",[t._v("Condition")]),t._v("才需要去实现它；")])]),t._v(" "),a("p",[a("strong",[t._v("独占")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("tryAcquire(int)")]),t._v("：独占方式。尝试获取资源，成功则返回true，失败则返回false；")]),t._v(" "),a("li",[a("code",[t._v("tryRelease(int)")]),t._v("：独占方式。尝试释放资源，成功则返回true，失败则返回false；")])]),t._v(" "),a("p",[a("strong",[t._v("共享")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("tryAcquireShared(int)")]),t._v("：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源；")]),t._v(" "),a("li",[a("code",[t._v("tryReleaseShared(int)")]),t._v("：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false；")])]),t._v(" "),a("h3",{attrs:{id:"reentrantlock为例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock为例"}},[t._v("#")]),t._v(" ReentrantLock为例")]),t._v(" "),a("p",[t._v("（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的")])]),t._v(" "),a("h3",{attrs:{id:"countdownlatch为例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch为例"}},[t._v("#")]),t._v(" CountDownLatch为例")]),t._v(" "),a("p",[t._v("任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后"),a("code",[t._v("countDown()")]),t._v("一次，"),a("strong",[t._v("state")]),t._v("就会"),a("strong",[t._v("CAS")]),t._v("减一。当N子线程全部执行完毕，state=0，会"),a("code",[t._v("unpark()")]),t._v("主调用线程，主调用线程就会从"),a("code",[t._v("await()")]),t._v("函数返回，继续之后的动作。")]),t._v(" "),a("p",[t._v("一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现"),a("code",[t._v("tryAcquire-tryRelease")]),t._v("、"),a("code",[t._v("tryAcquireShared-tryReleaseShared")]),t._v("中的一种即可。但AQS也支持自定义同步器同时"),a("strong",[t._v("实现独占和共享两种方式，如ReentrantReadWriteLock。")])]),t._v(" "),a("br"),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("部分内容参考自：")]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://blog.csdn.net/mulinsen77/article/details/84583716?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param",target:"_blank",rel:"noopener noreferrer"}},[t._v("AQS详解"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/waterystone/p/4920797.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java并发之AQS详解"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);a.default=n.exports}}]);