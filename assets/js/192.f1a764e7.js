(window.webpackJsonp=window.webpackJsonp||[]).push([[192],{518:function(a,t,s){"use strict";s.r(t);var r=s(3),_=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"classloader-类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classloader-类加载器"}},[a._v("#")]),a._v(" ClassLoader 类加载器")]),a._v(" "),t("h3",{attrs:{id:"_1-定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[a._v("#")]),a._v(" 1.  定义：")]),a._v(" "),t("p",[a._v("**类加载：**通过一个类的全名称来获取此类的二进制文件字节流")]),a._v(" "),t("p",[a._v("**类加载器：**实现类加载功能的代码模块")]),a._v(" "),t("hr"),a._v(" "),t("p",[t("img",{attrs:{src:"C:%5CUsers%5Cj2726%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1563593470134.png",alt:"1563593470134"}})]),a._v(" "),t("h3",{attrs:{id:"_2-jdk内置的三大类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-jdk内置的三大类加载器"}},[a._v("#")]),a._v(" 2. JDK内置的三大类加载器")]),a._v(" "),t("h4",{attrs:{id:"bootstrap-启动类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap-启动类加载器"}},[a._v("#")]),a._v(" BootStrap （启动类加载器）")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("使用C++语言实现，是JVM自身的一部分,独立于JVM外部，并且无法被Java程序直接使用")])]),a._v(" "),t("li",[t("p",[a._v("负责将存放于"),t("strong",[a._v("JAVA_HOME\\lib")]),a._v("目录下==能被 JVM 识别==的所有类库(rt.jar---java基础类库[Object类，Data类])加载到 JVM中")]),a._v(" "),t("blockquote",[t("p",[a._v("**jar文件：**java的压缩文件，存放编译好的class文件")])])])]),a._v(" "),t("h4",{attrs:{id:"extclassloader-拓展类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extclassloader-拓展类加载器"}},[a._v("#")]),a._v(" ExtClassLoader(拓展类加载器)")]),a._v(" "),t("ol",[t("li",[a._v("使用Java语言实现，可以被Java程序直接引用")]),a._v(" "),t("li",[a._v("负责将存放于 "),t("strong",[a._v("JAVA_HOME\\lib\\ext")]),a._v(" (xml文件解析类，Swing界面框架类) 目录下的所有能被 JVM 识别的类库")])]),a._v(" "),t("h4",{attrs:{id:"appclassloader-应用程序类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#appclassloader-应用程序类加载器"}},[a._v("#")]),a._v(" AppClassloader（应用程序类加载器）")]),a._v(" "),t("ol",[t("li",[a._v("使用Java语言实现，如果用户没有实现自定义类加载器，则APPClassLoader就是程序中默认的类加载器")]),a._v(" "),t("li",[a._v("负责加载用户"),t("strong",[a._v("classpath")]),a._v("指定的类库")])]),a._v(" "),t("h3",{attrs:{id:"_3-类加载器的双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-类加载器的双亲委派模型"}},[a._v("#")]),a._v(" 3. 类加载器的双亲委派模型")]),a._v(" "),t("p",[a._v("**定义：**四种类加载器的层次模型称为==类加载器的双亲委派模型==")]),a._v(" "),t("p",[t("img",{attrs:{src:"C:%5CUsers%5Cj2726%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1563595225153.png",alt:"1563595225153"}})]),a._v(" "),t("p",[t("strong",[a._v("工作流程：")])]),a._v(" "),t("p",[a._v("如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此。==因此，所有的加载请求都应当传送到顶层的"),t("code",[a._v("BootStrap")]),a._v("加载器中，只有当父加载器反馈无法完成这个加载请求时(在自己搜索范围中没有找到此类)，子加载器才会尝试自己去加载。==")]),a._v(" "),t("p",[t("strong",[a._v("存在意义：")])]),a._v(" "),t("p",[a._v("==双亲委派模型对于保障Java程序的稳定运行十分重要==")]),a._v(" "),t("blockquote",[t("p",[a._v("例如：")]),a._v(" "),t("p",[t("strong",[a._v("java.lang.Object")]),a._v(" ，它存放在"),t("strong",[a._v("rt.jar")]),a._v(" 中，由于双亲委派模型的存在，无论哪一类类加载器加载此类，最终都是委派给处于顶端的启动类加载器进行加载。因此，Object类在程序的各种类加载器环境中都是同一个类")])]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("比较两个类是否相等的前提条件：")])]),a._v(" "),t("p",[a._v("这俩个类是由同一个类加载器加载的，只要加载这俩个类的类加载器不通，则这俩个类不相同...")])]),a._v(" "),t("h3",{attrs:{id:"_4-反射与动态代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-反射与动态代理"}},[a._v("#")]),a._v(" 4. 反射与动态代理")])])}),[],!1,null,null,null);t.default=_.exports}}]);