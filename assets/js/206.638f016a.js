(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{538:function(v,_,a){"use strict";a.r(_);var t=a(3),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"_1-执行引擎概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-执行引擎概述"}},[v._v("#")]),v._v(" 1. 执行引擎概述")]),v._v(" "),_("p",[v._v("Java程序能够跨平台执行的原因并不是语言本身具备的的跨平台，而是每个平台对应实现了相应的虚拟机，来保证在不同操作系统下执行的一致性。"),_("strong",[v._v("是不同操作系统下的虚拟机，保证了Java的跨平台特性")]),v._v("。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200707000901.png",alt:""}})]),v._v(" "),_("p",[v._v("JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为"),_("strong",[v._v("字节码指令不等价于本地机器指令")]),v._v("，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200707002912.png",alt:""}})]),v._v(" "),_("p",[v._v("那么，如果想要让一个Java程序运行起来，"),_("strong",[v._v("执行引擎（ Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令")]),v._v("才可以。")]),v._v(" "),_("p",[v._v("简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的翻译官。")]),v._v(" "),_("h2",{attrs:{id:"_2-执行引擎工作过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-执行引擎工作过程"}},[v._v("#")]),v._v(" 2. 执行引擎工作过程")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200707091130.png",alt:""}})]),v._v(" "),_("ol",[_("li",[_("p",[v._v("执行引擎要执行什么字节码指令，完全依赖于PC计数器。PC计数器存放着下一条执行指令的地址。")])]),v._v(" "),_("li",[_("p",[v._v("每当执行引擎执行完一条指令后，PC计数器会更新下一条指令的地址。执行引擎寻得后执行。")])]),v._v(" "),_("li",[_("p",[v._v("方法在执行的过程中，执行引擎有可能会通过存储在"),_("strong",[v._v("局部变量表中的对象引用")]),v._v("，准确定位到存储在Java堆区中的对象实例信息，以及通过"),_("strong",[v._v("对象头中的元数据指针")]),v._v("定位到目标对象的类型信息")])])]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"_3-前端编译器与后端编译器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-前端编译器与后端编译器"}},[v._v("#")]),v._v(" 3. 前端编译器与后端编译器")]),v._v(" "),_("blockquote",[_("p",[v._v("👉参考文章【"),_("a",{attrs:{href:"https://blog.csdn.net/yu870646595/article/details/78987805",target:"_blank",rel:"noopener noreferrer"}},[v._v("Java编译分类：前端编译和后端编译是如何划分的"),_("OutboundLink")],1),v._v("】")])]),v._v(" "),_("p",[v._v("Java程序代码需要编译后才能在虚拟机中运行，编译涉及到非常多的知识层面：编译原理、语言规范、虚拟机规范、本地机器码优化等。")]),v._v(" "),_("p",[v._v("下面我们先来看Java体系中的三种编译方式：前端编译、即时编译（JIT编译）、静态提前编译（AOT编译）")]),v._v(" "),_("h3",{attrs:{id:"前端编译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端编译"}},[v._v("#")]),v._v(" 前端编译")]),v._v(" "),_("p",[v._v("把Java源码文件"),_("code",[v._v(".java")]),v._v("编译成Class文件"),_("code",[v._v(".class")]),v._v("的过程；")]),v._v(" "),_("p",[v._v("即把满足Java语言规范的程序转化为满足JVM规范所要求格式的功能；")]),v._v(" "),_("p",[_("strong",[v._v("优点：")])]),v._v(" "),_("p",[v._v("这阶段的优化是指程序编码方面的；")]),v._v(" "),_("ul",[_("li",[_("p",[v._v('许多Java语法新特性（"语法糖"：泛型、内部类等等），是靠前端编译器实现的，而不是依赖虚拟机；')])]),v._v(" "),_("li",[_("p",[v._v("编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度；")])])]),v._v(" "),_("p",[_("strong",[v._v("缺点：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("对代码运行效率几乎没有任何优化措施；")])]),v._v(" "),_("li",[_("p",[v._v("解释执行效率较低，所以需要结合下面的JIT编译；")])])]),v._v(" "),_("p",[_("strong",[v._v("前端编译器")]),v._v("：Oracle javac、Eclipse JDT中的增量式编译器（ECJ）等;")]),v._v(" "),_("h3",{attrs:{id:"后端编译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#后端编译"}},[v._v("#")]),v._v(" 后端编译")]),v._v(" "),_("p",[v._v("通过Java虚拟机（JVM）内置的即时编译器（Just In Time Compiler，JIT编译器）；在运行时把Class文件字节码编译成本地机器码的过程；")]),v._v(" "),_("p",[_("strong",[v._v("优点：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v('通过在运行时收集监控信息，把"热点代码"（Hot Spot Code）编译成与本地平台相关的机器码，并进行各种层次的优化；')])]),v._v(" "),_("li",[_("p",[v._v("可以大大提高执行效率；")])])]),v._v(" "),_("p",[_("strong",[v._v("缺点：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("收集监控信息影响程序运行；")])]),v._v(" "),_("li",[_("p",[v._v("编译过程占用程序运行时间（如使得启动速度变慢）；")])]),v._v(" "),_("li",[_("p",[v._v("编译机器码占用内存；")])])]),v._v(" "),_("p",[_("strong",[v._v("JIT编译器")]),v._v("：HotSpot虚拟机的C1、C2编译器等；")]),v._v(" "),_("p",[v._v("程序运行前，直接把Java源码文件"),_("code",[v._v(".java")]),v._v("编译成本地机器码的过程；")]),v._v(" "),_("p",[v._v("另外，JIT编译速度及编译结果的优劣，是衡量一个JVM性能的很重要指标；")]),v._v(" "),_("p",[v._v("所以对程序运行性能优化集中到这个阶段，也就是说可以对这个阶段进行"),_("strong",[v._v("JVM调优")]),v._v("；")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"_4-java程序的编译与执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-java程序的编译与执行"}},[v._v("#")]),v._v(" 4. Java程序的编译与执行")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200707093416.png",alt:""}})]),v._v(" "),_("p",[_("strong",[v._v("什么是解释器？什么是JIT编译器？")])]),v._v(" "),_("p",[_("strong",[v._v("解释器（ Interpreter）")]),v._v("：当Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为"),_("mark",[v._v("对应平台的本地机器指令")]),v._v("执行")]),v._v(" "),_("ul",[_("li",[v._v("解释器将"),_("code",[v._v(".class")]),v._v("字节码指令"),_("em",[v._v("解释")]),v._v("为本地机器指令")])]),v._v(" "),_("p",[_("strong",[v._v("JIT（ Just In Time Compiler）即时编译器")]),v._v("：就是虚拟机将源代码"),_("mark",[v._v("直接编译")]),v._v("成和本地机器平台相关的机器语言")]),v._v(" "),_("ul",[_("li",[v._v("JIT将"),_("code",[v._v(".java")]),v._v("代码直接"),_("em",[v._v("编译")]),v._v("为本地机器指令")])]),v._v(" "),_("blockquote",[_("p",[v._v("这里所说的编译器是指后端编译器")])]),v._v(" "),_("h3",{attrs:{id:"理解java-半编译半解释型语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#理解java-半编译半解释型语言"}},[v._v("#")]),v._v(" 理解Java-半编译半解释型语言")]),v._v(" "),_("p",[_("strong",[v._v("为什么Java被称作是半编译半解释型语言呢？它和C++的编译型语言和JavaScript解释型语言的差异到底在哪里？")])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("💔首先，我自己的一个"),_("strong",[v._v("误区")]),v._v("理解为：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Java先通过"),_("code",[v._v("javac")]),v._v("将源文件编译为"),_("code",[v._v(".class")]),v._v("文件，但是"),_("code",[v._v(".class")]),v._v("文件并不能够直接执行，所以叫做半编译")])]),v._v(" "),_("li",[_("p",[v._v("然后，再由JVM来解释执行"),_("code",[v._v(".class")]),v._v("文件，称为半解释型语言")])])]),v._v(" "),_("p",[v._v("半编译半解释就是"),_("code",[v._v(".java")]),v._v(" 源文件编译了，但是不能够直接执行，故此得名。")]),v._v(" "),_("p",[v._v("❌但是，这是理解的误区。学到这里，才发现这样理解是错误的（但是老师是这么讲的，我也没深入探究）。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("Java称为半编译半解释语言的根本原因，是：")]),v._v(" "),_("p",[v._v("✔"),_("strong",[v._v("执行引擎在解释执行字节码文件时，既可以使用解释器Interpreter来执行，又可以使用JIT（ Just In Time Compiler）即时编译器来执行")]),v._v("。所以叫半编译半解释型")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200707101215.png",alt:""}})]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("JDK1.0时，将Java语言定位为“解释执行”是比较准确的。再后来， Java也发展出可以直接生成本地代码的编译器。")]),v._v(" "),_("p",[v._v("现在JWM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"todo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#todo"}},[v._v("#")]),v._v(" TODO")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("[ ] 解释器的使用")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 解释器与JIT的并存")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 热点代码的探测确定")])]),v._v(" "),_("li",[_("p",[v._v("[ ] C1与C2编译器")])]),v._v(" "),_("li",[_("p",[v._v("[ ] AOT编译器")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);