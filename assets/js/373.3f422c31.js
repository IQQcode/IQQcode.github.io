(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{696:function(s,a,t){"use strict";t.r(a);var e=t(3),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("MySQL的基本架构示意图，可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232859.png",alt:"aa"}})]),s._v(" "),a("p",[s._v("大体来说，MySQL 可以分为：")]),s._v(" "),a("ul",[a("li",[s._v("Server 层")]),s._v(" "),a("li",[s._v("存储引擎层")])]),s._v(" "),a("p",[s._v("Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。")]),s._v(" "),a("p",[s._v("而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5版本开始成为了默认存储引擎。")]),s._v(" "),a("p",[s._v("执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。")]),s._v(" "),a("h2",{attrs:{id:"_1-连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接器"}},[s._v("#")]),s._v(" 1. 连接器")]),s._v(" "),a("p",[s._v("第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("mysql "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-u")]),s._v(" root "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_2-查询缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-查询缓存"}},[s._v("#")]),s._v(" 2. 查询缓存")]),s._v(" "),a("p",[a("strong",[s._v("连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。")])]),s._v(" "),a("p",[s._v("MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。")]),s._v(" "),a("p",[s._v("如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。")]),s._v(" "),a("p",[s._v("​    MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。")]),s._v(" "),a("h2",{attrs:{id:"_3-分析器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-分析器"}},[s._v("#")]),s._v(" 3. 分析器")]),s._v(" "),a("p",[a("strong",[s._v("如果没有命中查询缓存，就要开始真正执行语句了。")])]),s._v(" "),a("p",[s._v("首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。")]),s._v(" "),a("p",[s._v("分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。")]),s._v(" "),a("p",[s._v("MySQL 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成 “表名T”，把字符串 “ID” 识别成 “列ID”。")]),s._v(" "),a("p",[s._v("做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足 MySQL 语法。")]),s._v(" "),a("p",[s._v("如果你的语句不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比如下面这个语句 select 少打了开头的字母 “s”。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" elect * from t where "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("ID")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\nERROR "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1064")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("42000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": You have an error "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" your SQL syntax"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" check the manual that corresponds to your MySQL server version "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" the right syntax to **use near** "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'elect * from t where ID=1'")]),s._v(" at line "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧挨着 “use near” 的内容。")]),s._v(" "),a("h2",{attrs:{id:"_4-优化器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-优化器"}},[s._v("#")]),s._v(" 4. 优化器")]),s._v(" "),a("p",[s._v("经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。")]),s._v(" "),a("p",[s._v("优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：")]),s._v(" "),a("p",[s._v("mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;")]),s._v(" "),a("p",[s._v("1、既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。")]),s._v(" "),a("p",[s._v("2、也可以先从表 t2 里面取出 c=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。")]),s._v(" "),a("p",[s._v("这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。")]),s._v(" "),a("p",[s._v("优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。")]),s._v(" "),a("h2",{attrs:{id:"_5-执行器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-执行器"}},[s._v("#")]),s._v(" 5. 执行器")]),s._v(" "),a("p",[s._v("MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。")]),s._v(" "),a("p",[s._v("开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" * from T where "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("ID")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\nERROR "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1142")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("42000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": SELECT "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v(" denied to user "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'b'")]),s._v("@"),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'localhost'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" table "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'T'")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("如果有权限，就打开表继续执行。打开表的时候，优化器就会根据表的引擎定义，去使用这个引擎提供的接口。")]),s._v(" "),a("p",[s._v("比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：")]),s._v(" "),a("p",[s._v("1、调用 InnoDB 引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；\n2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。\n3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。")]),s._v(" "),a("p",[s._v("至此，这个语句就执行完成了。")]),s._v(" "),a("p",[s._v("对于有索引的表，执行的逻辑也差不多。第一次调用的是 “取满足条件的第一行” 这个接口，之后循环取 “满足条件的下一行” 这个接口，这些接口都是引擎中已经定义好的。")]),s._v(" "),a("p",[s._v("你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。")]),s._v(" "),a("p",[s._v("在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。")])])}),[],!1,null,null,null);a.default=r.exports}}]);