(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{537:function(_,v,t){"use strict";t.r(v);var a=t(3),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"_1-jvm简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-jvm简介"}},[_._v("#")]),_._v(" 1. JVM简介")]),_._v(" "),v("p",[_._v("虚拟机简介 ：JVM(Java Virtual Machine的简称，意为Java虚拟机)")]),_._v(" "),v("p",[_._v("虚拟机 ：指通过软件模拟的"),v("strong",[_._v("具有完整硬件功能的、运行在一个完全隔离的环境中")]),_._v("的完整计算机系统")]),_._v(" "),v("p",[_._v("常见的虚拟机 ：JVM、VMwave、Virtual Box")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("PS：")]),_._v(" Java虚拟机并不是只能跑Java程序，只要是符合JVM的运行规范的语言，在编译后都可由JVM来解释执行，如Scala、Kotlin、JRuby等。")])]),_._v(" "),v("p",[_._v("Java虚拟机特点：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("一次编译，到处运行")])]),_._v(" "),v("li",[v("p",[_._v("自动内存管理")])]),_._v(" "),v("li",[v("p",[_._v("自动垃圾回收功能")])])]),_._v(" "),v("h3",{attrs:{id:"_2-jvm内存区域划分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm内存区域划分"}},[_._v("#")]),_._v(" 2. JVM内存区域划分")]),_._v(" "),v("p",[v("strong",[_._v("JVM内存区域划分 ---- 6大区域")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019091819193185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIzMjk1NQ==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("h4",{attrs:{id:"线程私有内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程私有内存"}},[_._v("#")]),_._v(" 线程私有内存")]),_._v(" "),v("p",[v("strong",[_._v("程序计数器、虚拟机栈、本地方法栈")])]),_._v(" "),v("p",[v("strong",[_._v("什么是线程私有?")])]),_._v(" "),v("blockquote",[v("p",[_._v("由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，因此在任何一个确定的时刻，一个处理器(多核处理器则指的是一个内核)都只会执行一条线程中的指令。因此"),v("strong",[_._v("为了切换线程后能恢复到正确的执行位置，每条线程都需要独立的程序计数器")]),_._v('，各条线程之间计数器互不影响，独立存储。我们就把类似这类区域称之为"线程私有"的内存。')])]),_._v(" "),v("p",[_._v("线程私有 ：")]),_._v(" "),v("ul",[v("li",[_._v("程序计数器、虚拟机栈、本地方法栈的生命周期与线程的生命周期完全相同；")]),_._v(" "),v("li",[_._v("随着线程的创建而创建，随着线程的销毁而回收.")]),_._v(" "),v("li",[_._v("不同线程这三块内存彼此隔离.")])]),_._v(" "),v("h5",{attrs:{id:"i-程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-程序计数器"}},[_._v("#")]),_._v(" I. 程序计数器 :")]),_._v(" "),v("p",[_._v("程序计数器是一块比较小的内存空间，可以看做是当前线程所执行的程序的行号指示器")]),_._v(" "),v("p",[v("font",{attrs:{color:"[[FF7F50]]",size:"4"}},[_._v("程序计数器内存区是JVM中唯一 一个没有规定任何OOM(Out-Of-MemoryError)异常的区域！")])],1),_._v(" "),v("ul",[v("li",[_._v("如果当前线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；")]),_._v(" "),v("li",[_._v("若执行的是"),v("code",[_._v("native")]),_._v("方法，计数器值为0")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://wenku.baidu.com/view/e673740e854769eae009581b6bd97f192279bff2.html",target:"_blank",rel:"noopener noreferrer"}},[v("strong",[_._v("微机原理 中断响应")]),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("我们来回顾一下"),v("strong",[_._v("CPU对中断的响应")]),_._v(" ：")]),_._v(" "),v("p",[_._v("大二上学期学的微机原理，早忘光了\n"),v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190918193513345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIzMjk1NQ==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),_._v(" "),v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190918193752890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIzMjk1NQ==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("这里的程序计数器就类似于"),v("strong",[_._v("保留现场、保护断点")]),_._v('这一操作，当CPU响应中断时，会把断点记录在一个寄存器中，转而去响应中断. 而在JVM中，程序计数器充当了这一角色，我们就把程序计数器存放数据的这一区域称之为"线程私有"内存.')]),_._v(" "),v("h5",{attrs:{id:"ii-虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ii-虚拟机栈"}},[_._v("#")]),_._v(" II. 虚拟机栈 ：")]),_._v(" "),v("p",[_._v("虚拟机栈描述的是Java ==方法执行的内存模型==")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("每个方法执行的同时都会创建一个"),v("strong",[_._v("栈帧")]),_._v("用于存储==局部变量表、操作数栈、动态链接、方法出口==等信息")])]),_._v(" "),v("li",[v("p",[_._v("每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈和出栈的过程")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019091820501014.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190918204936959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIzMjk1NQ==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[v("strong",[_._v("局部变量表 :")]),_._v(" 存放了编译器可知的各种基本数据类型(8大基本数据类型)、对象引用")]),_._v(" "),v("ul",[v("li",[v("font",{attrs:{color:"red",size:"4"}},[_._v("-Xss设置栈容量")])],1)]),_._v(" "),v("p",[_._v("此区域一共会产生以下两种异常 :")]),_._v(" "),v("ol",[v("li",[_._v("如果线程请求的栈深度大于虚拟机所允许的深度(-Xss设置栈容量)，将会抛出"),v("code",[_._v("StackOverFlowError")]),_._v("异常")]),_._v(" "),v("li",[_._v("虚拟机在==动态扩容==时无法申请到足够的内存，会抛出"),v("code",[_._v("OOM(OutOfMemoryError)")]),_._v("异常")])]),_._v(" "),v("p",[v("strong",[_._v("OOM产生的原因：")])]),_._v(" "),v("p",[_._v("内存泄露 ：参生的对象永远无法被垃圾回收器回收")]),_._v(" "),v("p",[_._v("内存溢出 ：当前堆的空间过小，没有足够空间容纳新的对象（适当的将堆的大小适当扩大）")]),_._v(" "),v("h5",{attrs:{id:"iii-本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iii-本地方法栈"}},[_._v("#")]),_._v(" III. 本地方法栈")]),_._v(" "),v("p",[v("code",[_._v("native")]),_._v("方法的内存模型")]),_._v(" "),v("p",[v("strong",[_._v("HotSpot")]),_._v(" : (Java默认的虚拟机)  本地方法栈与虚拟机栈合二为一")]),_._v(" "),v("h4",{attrs:{id:"线程共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程共享内存"}},[_._v("#")]),_._v(" 线程共享内存")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("线程共享 ：")]),_._v(" 所有线程共享Java堆、方法区、运行时常量池这三块内存，彼此不隔离")])]),_._v(" "),v("h5",{attrs:{id:"i-java堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-java堆"}},[_._v("#")]),_._v(" I. Java堆")]),_._v(" "),v("ul",[v("li",[_._v("Java堆(Java Heap)是JVM所管理的最大内存区域，"),v("strong",[_._v("所有的对象实例以及数组都要在堆上分配")])]),_._v(" "),v("li",[_._v("Java堆是==垃圾回收器==的主要区域(GC堆)，Java堆可以处在物理上不连续的内存空间中")]),_._v(" "),v("li",[_._v("Java堆在虚拟机中都是可扩展的"),v("font",{attrs:{color:"red",size:"4"}},[_._v("(-Xmx设置堆的最大值,-Xms设置最小值)")])],1),_._v(" "),v("li",[_._v("堆中没有足够的内存完成实例分配且堆无法再拓展时，会抛出OOM异常")])]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("JVM产生OOM的原因：")])]),_._v(" "),v("ul",[v("li",[_._v("栈：虚拟机在"),v("font",{attrs:{color:"[[FF7F50]]",size:"3"}},[_._v("动态扩容")]),_._v("时无法申请到足够的内存")],1),_._v(" "),v("li",[_._v("堆：堆中没有足够的内存完成实例分配且堆无法再拓展时")])])]),_._v(" "),v("h5",{attrs:{id:"ii-方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ii-方法区"}},[_._v("#")]),_._v(" II. 方法区")]),_._v(" "),v("ul",[v("li",[_._v("存储 被JVM加载的类信息、常量、静态变量、编译后的代码等.")]),_._v(" "),v("li",[_._v('方法区也被称为"永久代"(JDK8已经被元空间取代)')])]),_._v(" "),v("h5",{attrs:{id:"iii-运行时常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iii-运行时常量池"}},[_._v("#")]),_._v(" III. 运行时常量池")]),_._v(" "),v("p",[_._v("运行时常量池是方法区的一部分，存放字面量与符号引用")]),_._v(" "),v("p",[_._v("字面量 : 字符串、final常量、基本数据类型的值(直接写出来的值)")]),_._v(" "),v("p",[_._v("符号引用 : 拿着符号引用能够找到具体的类或方法")]),_._v(" "),v("blockquote",[v("p",[_._v("下一节 ： "),v("a",{attrs:{href:"https://blog.csdn.net/weixin_43232955/article/details/100997167",target:"_blank",rel:"noopener noreferrer"}},[v("strong",[_._v("JVM(二)垃圾回收器与内存分配策略")]),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);