(window.webpackJsonp=window.webpackJsonp||[]).push([[407],{732:function(_,v,t){"use strict";t.r(v);var r=t(3),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-udp协议特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-udp协议特点"}},[_._v("#")]),_._v(" 1. UDP协议特点")]),_._v(" "),v("ol",[v("li",[_._v("UDP是"),v("strong",[_._v("无连接")]),_._v("的，减少了开销和发送时延")]),_._v(" "),v("li",[_._v("UDP尽最大努力交付，"),v("strong",[_._v("不保证可靠交付")])]),_._v(" "),v("li",[_._v("UDP是"),v("strong",[_._v("面向报文")]),_._v("传输，适合一次性传输"),v("strong",[_._v("少量")]),_._v("数据")]),_._v(" "),v("li",[_._v("UDP无拥塞控制，适合实时传输（推流直播）")]),_._v(" "),v("li",[_._v("UDP支持一对一、一对多、多对一和多对多的交互通信")]),_._v(" "),v("li",[_._v("UDP首部为"),v("code",[_._v("8B")]),_._v("，TCP为"),v("code",[_._v("20B")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200726161801.png",alt:""}})]),_._v(" "),v("p",[_._v("面向报文传输：")]),_._v(" "),v("p",[_._v("UDP不会对应用层传下的报文做处理，直接封装在报文段中，加上"),v("u",[_._v("UDP首部")]),_._v("向网络层发送。")]),_._v(" "),v("p",[_._v("网络层对过长的报文段做分片处理，满足MTU最大传送单元的要求。")]),_._v(" "),v("br"),_._v(" "),v("h2",{attrs:{id:"_2-udp首部格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-udp首部格式"}},[_._v("#")]),_._v(" 2. UDP首部格式")]),_._v(" "),v("p",[v("strong",[_._v("UDP首部为8B")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200726163023.png",alt:""}})]),_._v(" "),v("ul",[v("li",[v("p",[_._v("16位源端口： 数据发送方的端口号")])]),_._v(" "),v("li",[v("p",[_._v("16位目的端口： 数据接受方的端口号")])]),_._v(" "),v("li",[v("p",[_._v("16位UDP长度：UDP报文的字节长度（首部+数据）")])]),_._v(" "),v("li",[v("p",[_._v("16位UDP校验和：检验整个UDP数据报的正确性")])])]),_._v(" "),v("blockquote",[v("p",[_._v("分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“"),v("strong",[_._v("端口不可达")]),_._v("”差错报告报文。")])]),_._v(" "),v("h2",{attrs:{id:"_3-udp伪首部校验"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-udp伪首部校验"}},[_._v("#")]),_._v(" 3.UDP伪首部校验")]),_._v(" "),v("p",[_._v("UDP的检验和是把"),v("strong",[_._v("首部和数据部分一起检验")]),_._v("。")]),_._v(" "),v("p",[_._v("伪首部校验，即检查了UDP用户数据报的源端口号和目的端口号及数据部分，又检查了IP数据报的源IP地址和目的地址。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200726163525.png",alt:""}})]),_._v(" "),v("p",[v("strong",[_._v("伪首部校验UDP数据报")])]),_._v(" "),v("blockquote",[v("p",[_._v("假定数据报文为7B")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200726165539.png",alt:""}})]),_._v(" "),v("p",[v("code",[_._v("12B")]),_._v("伪首部 + "),v("code",[_._v("8B")]),_._v("UDP首部 + "),v("code",[_._v("7B")]),_._v("报文数据 "),v("strong",[_._v("二进制16bit反码求和")])]),_._v(" "),v("h2",{attrs:{id:"_3-【udp怎么保证可靠传输】"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-【udp怎么保证可靠传输】"}},[_._v("#")]),_._v(" 3. 【UDP怎么保证可靠传输】")]),_._v(" "),v("p",[_._v("在传输层UDP协议无法保证可靠传输，只能在"),v("strong",[_._v("应用层来实现可靠")])]),_._v(" "),v("p",[_._v("要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的"),v("strong",[_._v("超时重传")]),_._v("，"),v("strong",[_._v("有序接受")]),_._v("，"),v("strong",[_._v("应答确认")]),_._v("，"),v("strong",[_._v("滑动窗口流量控制等机制")]),_._v("，等于说要在应用层实现TCP协议的可靠数据传输机制。比如使用")]),_._v(" "),v("ul",[v("li",[_._v("UDP数据包+序列号")]),_._v(" "),v("li",[_._v("UDP数据包+时间戳等方法")])]),_._v(" "),v("p",[_._v("在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输")]),_._v(" "),v("br"),_._v(" "),v("h3",{attrs:{id:"_1-确认机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-确认机制"}},[_._v("#")]),_._v(" 1. 确认机制")]),_._v(" "),v("p",[_._v("添加"),v("code",[_._v("seq/ack")]),_._v("机制，确保数据发送到对端")]),_._v(" "),v("h3",{attrs:{id:"_2-重发机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-重发机制"}},[_._v("#")]),_._v(" 2. 重发机制")]),_._v(" "),v("p",[v("strong",[_._v("【自动重发机制】")])]),_._v(" "),v("p",[_._v("自动重发机制是消息发送时启动一个定时器，如果在规定的一段时间内未收到接收方的确认消息，则断定这段时间内发送的报文已经丢失并进行重发。")]),_._v(" "),v("p",[v("strong",[_._v("【请求重发机制】")])]),_._v(" "),v("p",[_._v("请求重发机制则是在接收方收到发送方发来的传输结束消息后，在接收方对收到的所有报文序号进行检测，如果发现某些序号的报文缺失，接收方主动请求重发缺失的序号对应的报文。")]),_._v(" "),v("hr"),_._v(" "),v("p",[v("strong",[_._v("设计要点：")])]),_._v(" "),v("p",[_._v("1、自动重发机制")]),_._v(" "),v("p",[_._v("通信发送方和接收方都维持一个自动重发定时器，在通信开始前会检查自动重发定时器是否启动，如果没有启动，就会启动这个定时器。如果在一个特定时间间隔内发送方没有收到来自接收方的任何确认消息，或者接收方没有到发送方的通道检测报文。这时系统会将这个定时器归零，并将这段时间内发送的消息重发一遍，把记录重发次数变量加1。如果过在规定的时间内依然没有收到对方的任何确认信息，则重新将定时器归0， 执行重发操作并将重发次数加1，如此循环，在重发次数未达到指定数据之前，直到收到对方的一个确认消息，然后停止自动重发定时器，将重发次数清 0；否则证明传输路径出现问题。")]),_._v(" "),v("p",[_._v("2、请求重发机制")]),_._v(" "),v("p",[_._v("接收方记录着已收到数据包的序列以及未收到的数据包序列。当接收到分组结束包时，接收方就会启动定时器，检索该分组内未收到的数据包，如果数据包已全部接收到，则关闭定时器，进行下一个分组的传输。否则查找丢失 数据包的序号并依次发送请求重发数据包，在规定时间内接收发送方重发的数据包，然后定时器归 0，重新检索未收到数据包，并按上述情况做出反应，如此循环往复，直到最终完成该分组的传输过程。")]),_._v(" "),v("h3",{attrs:{id:"_3-错序重排机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-错序重排机制"}},[_._v("#")]),_._v(" 3. 错序重排机制")]),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[v("strong",[_._v("协议头结构中设置2个字节的序号字段")])])],1),_._v(" "),v("p",[v("strong",[_._v("每一个数据块编号，序号的范围是对端接收端的缓存队列的长度，每个编号是对应下标相对于之前的偏移量")])]),_._v(" "),v("p",[_._v("当发送端接收到对端发送的确认接收报文后，开始读取文件数据块内容写入协议数据区，为每一个数据块编制一个序号，序号的最大值要求与接收端维护的一个为了实现错序重排机制的动态表长度一致。序号排满后，后面的报文会在下一个分组中进行发送。这时发送端 会根据当前分组下读取的数据块大小及起始位置填写协议头中的字段，最后将数据包发送出去。接收端起初会生成一个动态数组用来存储接收到的数据包序号，当接收端准备好接收文件后将数组的每一位置为无效，每收到一个数据包，就会读取其序号字段值并将数组相应位置为有效，然后将数据区的内容写入文件。这样即使由于网络状况导致数据包不能按序到达，接收端也能根据数据包位置字段和大小字段将数据写入文件。序号字段在收到结束包后用于检索动态数组启动请求重传机制。")]),_._v(" "),v("h2",{attrs:{id:"_4-开源的基于udp的可靠协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-开源的基于udp的可靠协议"}},[_._v("#")]),_._v(" 4. 开源的基于UDP的可靠协议")]),_._v(" "),v("p",[_._v("开源程序利用UDP实现了可靠的数据传输。分别为 "),v("em",[v("strong",[_._v("RUDP、RTP、UDT")])]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"_1-rudp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-rudp"}},[_._v("#")]),_._v(" 1. RUDP")]),_._v(" "),v("blockquote",[v("p",[_._v("RUDP（Reliable User Datagram Protocol）")])]),_._v(" "),v("p",[v("strong",[_._v("RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等")]),_._v("，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。")]),_._v(" "),v("h3",{attrs:{id:"_2-rtp-real-time-protocol"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-rtp-real-time-protocol"}},[_._v("#")]),_._v(" 2. RTP（Real Time Protocol）")]),_._v(" "),v("blockquote",[v("p",[_._v("RTP（Real Time Protocol）")])]),_._v(" "),v("p",[v("strong",[_._v("RTP为数据提供了具有实时特征的端对端传送服务")]),_._v("，如在组播或单播网络服务下的交互式视频音频或模拟数据。")]),_._v(" "),v("p",[_._v("应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。")]),_._v(" "),v("p",[_._v("RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。")]),_._v(" "),v("h3",{attrs:{id:"_3-udt"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-udt"}},[_._v("#")]),_._v(" 3. UDT")]),_._v(" "),v("blockquote",[v("p",[_._v("UDT（UDP-based Data Transfer Protocol）")])]),_._v(" "),v("p",[_._v("基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。"),v("strong",[_._v("UDT的主要目的是支持高速广域网上的海量数据传输")]),_._v("，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。")]),_._v(" "),v("p",[_._v("顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。")]),_._v(" "),v("p",[_._v("【参考】")]),_._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://blog.csdn.net/AaronHyk/article/details/81505562",target:"_blank",rel:"noopener noreferrer"}},[_._v("如何实现UDP的可靠传输"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/6c73a4585eba",target:"_blank",rel:"noopener noreferrer"}},[_._v("UDP如何实现可靠传输"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=s.exports}}]);