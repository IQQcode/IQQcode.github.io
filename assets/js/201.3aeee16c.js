(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{528:function(t,s,a){"use strict";a.r(s);var n=a(3),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-堆heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-堆heap"}},[t._v("#")]),t._v(" 1. 堆Heap")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629175321.png",alt:""}})]),t._v(" "),s("p",[t._v("一个进程对应一个JVM实例，一个JVM实例就对应一个运行时数据区Rutime Data Area（Runtime类是饿汉式单例）。一个进程对应多个线程，一个进程中的多个线程共享同一块堆空间，共享同一个方法区。")]),t._v(" "),s("p",[s("strong",[t._v("在方法结束后，堆中的对象不会立刻被移除，仅仅在执行引擎垃圾回收的时候才会被移除。")])]),t._v(" "),s("p",[t._v("堆，是GC（ Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。")]),t._v(" "),s("blockquote",[s("p",[t._v("👉【oracle官方文档】"),s("a",{attrs:{href:"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4",target:"_blank",rel:"noopener noreferrer"}},[t._v("The Structure of the Java Virtual Machine"),s("OutboundLink")],1)])]),t._v(" "),s("h3",{attrs:{id:"堆的核心-内存细分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的核心-内存细分"}},[t._v("#")]),t._v(" 堆的核心-内存细分")]),t._v(" "),s("p",[t._v("现代垃圾回收器大部分都是基于分代手机理论设计，堆空间细分为：")]),t._v(" "),s("blockquote",[s("p",[t._v("约定：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("新生区==>新生代==>年轻代")])]),t._v(" "),s("li",[s("p",[t._v("养老区==>老年区==>老年代")])]),t._v(" "),s("li",[s("p",[t._v("永久区==>永久代")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629152823.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("JDK 7及之前：")])]),t._v(" "),s("p",[t._v("新生代 + 老年代 + "),s("font",{attrs:{color:"green"}},[t._v("永久代")])],1),t._v(" "),s("p",[s("strong",[t._v("JDK 8及之后：")])]),t._v(" "),s("p",[t._v("新生代+  老年代 + "),s("font",{attrs:{color:"red"}},[t._v("元空间")])],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629161449.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("元空间、永久代是方法区具体的落地实现")])]),t._v(" "),s("h3",{attrs:{id:"堆空间大小设置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆空间大小设置"}},[t._v("#")]),t._v(" 堆空间大小设置")]),t._v(" "),s("p",[t._v("堆用来存储Java对象实例，堆的大小在JVM启动时就已经设定好了。堆空间的大小可以通过两个参数来设置：（-X表示虚拟机参数）")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("-Xms")]),t._v("(memory start)：堆区起始内存")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("-Xmx")]),t._v("(memory max)：堆区最大内存")])])]),t._v(" "),s("p",[t._v("一旦堆区的内存超过"),s("code",[t._v("-Xmx")]),t._v("锁指定的最大内存时，会抛出"),s("strong",[t._v("OutOfMemoryError")])]),t._v(" "),s("p",[t._v("通常会将"),s("code",[t._v("-Xms")]),t._v("和"),s("code",[t._v("-Xmx")]),t._v("两个参数配置相同的值，其目的是为了能够在GC后，不需要重新分隔计算堆区的大小，从而提高性能。")]),t._v(" "),s("p",[t._v("【默认情况下】")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("初始内存大小：物理内存的 1 /  64")])]),t._v(" "),s("li",[s("p",[t._v("最大内存大小：物理内存的 1 / 4")])])]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"_2-新生代和老年代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-新生代和老年代"}},[t._v("#")]),t._v(" 2. 新生代和老年代")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173208.png",alt:""}})]),t._v(" "),s("p",[t._v("其中新生代分为"),s("strong",[t._v("Eden区、Suvivor 0区、Survivor 1区")]),t._v("（有时也叫From区、To区）")]),t._v(" "),s("blockquote",[s("p",[t._v("元空间、永久代是方法区具体的落地实现")])]),t._v(" "),s("p",[s("strong",[t._v("堆空间占比分配：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701174154.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173511.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"对象内存分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象内存分配"}},[t._v("#")]),t._v(" 对象内存分配")]),t._v(" "),s("p",[t._v("一个对象被分配内存、到创建、再到到消亡，它经历了怎样的过程呢？我们通过这张图，来做具体说明：")]),t._v(" "),s("p",[t._v("【概念明确】：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Eden - 伊甸园区")])]),t._v(" "),s("li",[s("p",[t._v("Survivor - 幸存者区（Survivor0 - S0、Survivor1 - S1）")])]),t._v(" "),s("li",[s("p",[t._v("垃圾对象 - 不再使用的对象，即没有指向的对象")])]),t._v(" "),s("li",[s("p",[t._v("存活的对象 - 不是垃圾的对象（还被使用）")])]),t._v(" "),s("li",[s("p",[t._v("Tenured/Old - 老年区")])])]),t._v(" "),s("blockquote",[s("p",[t._v("Survivor0 - S0、Survivor1 - S1也称"),s("code",[t._v("from")]),t._v("区和"),s("code",[t._v("to")]),t._v("区。名称不是固定的，from是满的一个，to是空的一个。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701160046.png",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("假设首次Survivor0和Survivor1均为空")])]),t._v(" "),s("p",[s("strong",[t._v("1. 首先"),s("code",[t._v("new")]),t._v("参生的对象会放到Eden")])]),t._v(" "),s("p",[s("strong",[t._v("2. 当Eden区空间满了时，程序又需要创建对象。YGC/Minor GC（可达性分析算法）对Eden区的垃圾对象进行回收，将存活的对象放入到Survivor0区")]),t._v("。每个对象的年龄计数器"),s("code",[t._v("age")]),t._v(" + 1")]),t._v(" "),s("p",[s("strong",[t._v("3. 此时Eden为空，存活的对象放入到了S0中")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701164923.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("4. 继续在Eden区创建新对象，Eden区再次装满，触发Minor GC")])]),t._v(" "),s("p",[s("strong",[t._v("5. 再次将剩余存活的对象放入到Survivor区。此时，S0已满，放入到S1中")])]),t._v(" "),s("p",[s("strong",[t._v("6. 判断S0区中的对象还是否被使用，如不使用则回收，使用则放入到S1中。"),s("code",[t._v("age")]),t._v("计数器+1")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701165132.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("7. 此时Eden和S0为空，存活的对象均在S1中")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701170350.png",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("此时S0称为to区，s1称为from区")])]),t._v(" "),s("p",[s("strong",[t._v("8. Eden区中再次创建对象直至满为止，存活的对象放入S0中，同时判断S1中是否有可回收答垃圾对象")])]),t._v(" "),s("p",[s("strong",[t._v("9. 当Survivor区中有对象的对象计数器age达到阈值15时，将其从Survivor中晋升到Old区")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701170713.png",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("阈值设置参数：-XX:MaxTenuringThresho1d="),s("N",[t._v("进行设置")])],1)]),t._v(" "),s("hr"),t._v(" "),s("p",[s("strong",[t._v("【总结】：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to")])]),t._v(" "),s("li",[s("p",[t._v("关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。")])]),t._v(" "),s("li",[s("p",[t._v("80%左右的对象在新生代中就被销毁了，朝生夕死")])])]),t._v(" "),s("h3",{attrs:{id:"特殊情况讨论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊情况讨论"}},[t._v("#")]),t._v(" 特殊情况讨论")]),t._v(" "),s("hr"),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701182422.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("Q1：Survivor区满了会触发YGC/Minor GC吗？")])]),t._v(" "),s("ul",[s("li",[s("font",{attrs:{color:"red"}},[t._v("不会的。Survivor区满了不会触发YGC，但是它会被垃圾回收。")]),t._v("当每次堆Eden进行YGC时，会对Suevivor也进行判断回收。只不过区别于Eden，这个过程是被动的。")],1)]),t._v(" "),s("p",[s("strong",[t._v("Q2：当Survivor满了时怎么办？")])]),t._v(" "),s("ul",[s("li",[t._v("如果Eden回收完后，此时Survivor为满时，就将Eden中的存活对象直接放入到Old区中。即使"),s("code",[t._v("age")]),t._v("没有达到阈值，也有可能直接晋升到老年代（理解为跨级晋升）")])]),t._v(" "),s("p",[s("strong",[t._v("Q3：对象有可能一创建就放到老年代吗？")])]),t._v(" "),s("ul",[s("li",[t._v("有可能。在YGC之后，对于超大对象来说还是存放不下，直接放入到老年代")])]),t._v(" "),s("blockquote",[s("p",[t._v("超大对象一般是超长的字符串、超大的数组等")])]),t._v(" "),s("p",[s("strong",[t._v("Q4：超大对象老年代也放不下怎么办？")])]),t._v(" "),s("blockquote",[s("p",[t._v("针对不动态调整内存空间机制的虚拟机")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("先对老年代进行"),s("strong",[t._v("Major GC")]),t._v("，看是否能够存放，是则放入老年代")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Major GC")]),t._v("完之后还是放不下，抛出"),s("font",{attrs:{color:"red"}},[t._v("OOM")])],1)])]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"_3-代码调试分析说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-代码调试分析说明"}},[t._v("#")]),t._v(" 3. 代码调试分析说明")]),t._v(" "),s("p",[t._v("光靠概念是不行的，我们通过一段代码来详解一下上面的要点：")]),t._v(" "),s("p",[t._v("JVM分析工具是用的JDK自带的"),s("strong",[t._v("jvisualvm.exe")]),t._v("和第三方的")]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/chongyou/p/9681868.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用jvisualvm.exe工具查看java项目内存溢出"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.ej-technologies.com/products/jprofiler/overview.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java Profiler - JProfiler"),s("OutboundLink")],1)])]),t._v(" "),s("p",[s("strong",[t._v("【测试代码】")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HeapInstanceTest2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Random")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HeapInstanceTest2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HeapInstanceTest2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HeapInstanceTest2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("p",[t._v("在当前类中声明"),s("code",[t._v("byte")]),t._v("类型的字节数组，大小是随机的，然后不断创建并放入到ArrayList中")]),t._v(" "),s("p",[t._v("由于是随机大小，有一些创建的对象可能比Survivr区的空间还大，如下图动图所示，就直接放入到了Old区，这也是符合我们上面的描述的")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702093153.gif",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702094403.png",alt:""}})]),t._v(" "),s("p",[t._v("当Old也放满时，最终会产生"),s("strong",[t._v("OOM")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702094547.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"分析说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析说明"}},[t._v("#")]),t._v(" 分析说明")]),t._v(" "),s("p",[t._v("JProfiler查看内存图分区详情：")]),t._v(" "),s("p",[s("strong",[t._v("Eden：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702095324.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("Old：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702095350.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200702095759.png",alt:""}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("我们可以看到，Eden区会有一个峰值，当它满了之后就会进行YGC，此时Eden再次到达峰底")])]),t._v(" "),s("li",[s("p",[t._v("S0和S1交替执行")])])]),t._v(" "),s("p",[s("mark",[s("strong",[t._v("一般程序出现OOM的原因就是老年代空间不足造成的")])])]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"_4-minor-gc、major-gc、full-gc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-minor-gc、major-gc、full-gc"}},[t._v("#")]),t._v(" 4. Minor GC、Major GC、Full GC")]),t._v(" "),s("p",[t._v("JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分都指的是新生代。因为大多数情况下创建对象都是在新生代，对象是朝生夕死的，所以GC的频率会比较高。")]),t._v(" "),s("p",[t._v("针对HotSpot VM，GC按照回收区域会划分成两大类型：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("部分收集  Partial GC")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("全部收集  Full GC")])])])]),t._v(" "),s("hr"),t._v(" "),s("p",[s("strong",[t._v("【部分收集】：")]),t._v(" 不是完整收集整个Java堆的垃圾，又分为")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("新生代收集（Minor GC或Yang GC，称谓不同）：只对新生代收集")])]),t._v(" "),s("li",[s("p",[t._v("老年代收集（Major GC / Old GC）：只对老年代收集")])]),t._v(" "),s("li",[s("p",[t._v("混合收集（Mixed GC）：收集整个新生代和部分老年代（G1 GC）")])])]),t._v(" "),s("p",[s("strong",[t._v("【全部收集】：")]),t._v(" 收集整个Java堆和方法区的垃圾收集")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"新生代minor-gc触发机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新生代minor-gc触发机制"}},[t._v("#")]),t._v(" 新生代Minor GC触发机制")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是Eden代满， Survivor满不会引发GC。每次 Minor GC会清理年轻代的内存")])]),t._v(" "),s("li",[s("p",[t._v("因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快")])]),t._v(" "),s("li",[s("p",[t._v("Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行")])])]),t._v(" "),s("blockquote",[s("ul",[s("li",[s("p",[t._v("Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于GC引起。")])]),t._v(" "),s("li",[s("p",[t._v("Minor GC时，制造垃圾的用户线程会暂停，等待VM Threads标记完垃圾对象并回收完，用户线程才能执行，即为STW")])])])]),t._v(" "),s("h3",{attrs:{id:"老年代major-gc-full-gc触发机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#老年代major-gc-full-gc触发机制"}},[t._v("#")]),t._v(" 老年代Major GC/Full GC触发机制")]),t._v(" "),s("p",[s("strong",[t._v("Major GC 、 Full GC很多情况下是混合使用的，需要具体分辨老年代还是整堆收集。")])]),t._v(" "),s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("只有CMS才会有老年代单独收集的行为。")]),t._v(" 其余都可以理解为Full GC，都是对整堆收集，Major GC/Full GC可以理解为相同作用")])],1),t._v(" "),s("p",[t._v("指发生在老年代的GC，对象从老年代消失时，我们说Major GC或Full GC发生了")]),t._v(" "),s("p",[t._v("出现了 Major GC，经常会伴随至少一次的 "),s("strong",[t._v("Minor GC/YGC")])]),t._v(" "),s("blockquote",[s("p",[t._v("但并非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程")])]),t._v(" "),s("p",[t._v("在老年代空间不足时，会先尝试触发"),s("strong",[t._v("Minor GC")]),t._v("。如果之后空间还不足，则触发"),s("strong",[t._v("Major GC")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("由于老年代空间较大，Major GC的速度一般会比 Minor GC慢10倍以上，STW的时间更长")])]),t._v(" "),s("li",[s("p",[t._v("如果 MaJor GC后，内存还不足，就报"),s("strong",[t._v("OOM")])])])]),t._v(" "),s("h3",{attrs:{id:"full-gc触发机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#full-gc触发机制"}},[t._v("#")]),t._v(" Full GC触发机制")]),t._v(" "),s("p",[t._v("触发Full GC执行的情况有如下五种：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("调用 "),s("code",[t._v("System.gc()")]),t._v("时，系统建议执行Full GC，但是不必然执行")])]),t._v(" "),s("li",[s("p",[t._v("老年代空间不足")])]),t._v(" "),s("li",[s("p",[t._v("方法区空间不足")])]),t._v(" "),s("li",[s("p",[t._v("通过Minor GC后进入老年代的平均大小大于老年代的可用内存")])]),t._v(" "),s("li",[s("p",[t._v("对于超大对象，新生代放不下，则把该对象转存到老年代，且老年代的可用内存小于该对象大小，就会触发Full GC")])])]),t._v(" "),s("blockquote",[s("p",[t._v("Full GC是开发或调优中尽量要避免的，这样暂时时间会短一些")])]),t._v(" "),s("h2",{attrs:{id:"_5-java堆为什么要分代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-java堆为什么要分代"}},[t._v("#")]),t._v(" 5. Java堆为什么要分代")]),t._v(" "),s("p",[s("strong",[t._v("绝大部分对象都是朝生夕死的。")]),t._v(" 新生代存放不停更新迭代的对象，老年代存放多次GC后任然存活的对象。")]),t._v(" "),s("p",[t._v("Java堆为什么要分代？不分代就不能工作了吗？")]),t._v(" "),s("p",[t._v("分代的原因是方便管理和维护，提高效率。就像一个年级可以放到一个班也能上课，但是人数太多不好管理，所以要分班。")]),t._v(" "),s("p",[s("strong",[t._v("分代的唯一理由就是优化GC性能。")]),t._v(" 如果没有分代，在GC的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173208.png",alt:""}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("GC痛苦的事情是出现了很多大对象")])]),t._v(" "),s("li",[s("p",[t._v("更痛苦的事是很多的大对象是朝生夕死的")])])]),t._v(" "),s("h2",{attrs:{id:"_6-【线程的tlab-堆上保证线程安全】"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-【线程的tlab-堆上保证线程安全】"}},[t._v("#")]),t._v(" 6. 【线程的TLAB-堆上保证线程安全】")]),t._v(" "),s("p",[s("strong",[t._v("堆空间一定是共享的吗？ ———并不是！TLEB在堆上，是线程私有的")])]),t._v(" "),s("p",[t._v("TLAB（Thread Local Allocation Buffer），从"),s("strong",[t._v("内存模型")]),t._v("而不是垃圾收集的角度：")]),t._v(" "),s("p",[s("strong",[t._v("对Eden区域继续进行划分")]),t._v("，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内")]),t._v(" "),s("p",[t._v("多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为"),s("strong",[t._v("快速分配策略")])]),t._v(" "),s("p",[s("strong",[t._v("不是所有的对象")]),t._v("实例都能够在TLAB中成功分配内存，一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用"),s("strong",[t._v("加锁机制")]),t._v("来确保数据的"),s("strong",[t._v("原子性")]),t._v("，从而在Eden空间中分配内存")]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"一些说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一些说明"}},[t._v("#")]),t._v(" 一些说明")]),t._v(" "),s("p",[s("strong",[t._v("堆是分配对象存储的唯一选择吗？")])]),t._v(" "),s("p",[t._v("在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：")]),t._v(" "),s("p",[t._v("随着JIT编译期的发展与逃逸分析技术逐渐成熟，"),s("strong",[t._v("栈上分配、标量替换")]),t._v("优化技术将会导\n致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。")]),t._v(" "),s("p",[t._v("在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过"),s("strong",[t._v("逃逸分析")]),t._v("（Escape Analysis)后发现，"),s("strong",[s("u",[t._v("一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配")])]),t._v("。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的"),s("strong",[t._v("堆外存储技术")]),t._v("。")]),t._v(" "),s("p",[t._v("逃逸分析的基本行为就是分析对象动态作用域：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有\n发生逃逸。可以在栈上分配！")])])]),t._v(" "),s("li",[s("p",[t._v("当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃\n逸。例如作为调用参数传递到其他地方中")])])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//use a")]),t._v("\n    a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("strong",[t._v("没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间被移除")])]),t._v(" "),s("p",[t._v("使用逃逸分析，编译器可对如下代码进行优化：")]),t._v(" "),s("ul",[s("li",[t._v("栈上分配")]),t._v(" "),s("li",[t._v("同步省略")]),t._v(" "),s("li",[t._v("分离对象或者标量替换")])]),t._v(" "),s("p",[t._v("堆外存储技术，包括TLEB是为了能够减少GC的频率，避免出现同步问题，提高程序的性能。")])])}),[],!1,null,null,null);s.default=r.exports}}]);