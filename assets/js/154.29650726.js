(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{481:function(a,t,s){"use strict";s.r(t);var e=s(3),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("blockquote",[t("p",[a._v("Java类集面试题汇总")])]),a._v(" "),t("h2",{attrs:{id:"java集合类概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java集合类概述"}},[a._v("#")]),a._v(" Java集合类概述")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210617195625.png",alt:""}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200525154022.png",alt:""}})]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("List(顺序好帮手)：")]),a._v(" List接口存储顺序唯一，可以有序的存储对象")]),a._v(" "),t("li",[t("strong",[a._v("Set(有序不重复):")]),a._v(" 不允许重复的集合，不会有多个元素引用相同的对象")]),a._v(" "),t("li",[t("strong",[a._v("Map(用key找value):")]),a._v(" 使用键值对存储。Key唯一，Value可重复")])]),a._v(" "),t("p",[a._v("Collection")]),a._v(" "),t("ul",[t("li",[a._v("List：以特定顺序存储")]),a._v(" "),t("li",[a._v("ArrayList、LinkList、Vector")]),a._v(" "),t("li",[a._v("Set：不能包含重复的元素")]),a._v(" "),t("li",[a._v("HashSet、TreeSet")])]),a._v(" "),t("p",[a._v("Map")]),a._v(" "),t("ul",[t("li",[a._v("HashMap")]),a._v(" "),t("li",[a._v("HashTable")]),a._v(" "),t("li",[a._v("TreeMap")])]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("Collection：Collection是一个父接口，List和Set是继承自他的子接口，Collection是最基本的集合接口，Java SDK中不提供直接继承自Collection的类，而是提供继承自他子接口的类，如List何Set。所用的Collection类都支持一个"),t("code",[a._v("Iterator()")]),a._v("方法来遍历。")]),a._v(" "),t("p",[a._v("List：List接口是有序的，会精确的将元素插入到指定的位置，和下面的Set接口不同，List接口允许有相同元素")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("ArrayList：实现可变大小的数组，线程不安全")])]),a._v(" "),t("li",[t("p",[a._v("LinkedList：允许null元素，通常在首部或者尾部操作，所以常被使用做堆栈(stack)、队列(queue)和双向队列(deque)")])]),a._v(" "),t("li",[t("p",[a._v("Vector：类似于ArrayList，但Vector是同步的，Stack继承自Vector")])])]),a._v(" "),t("p",[a._v("Set：是一种不包含重复元素的Collection接口")]),a._v(" "),t("ul",[t("li",[a._v("HashSet：不能有重复元素，底层是使用HashMap来实现的")]),a._v(" "),t("li",[a._v("TreeSet： 不能有重复元素，对元素做排序（升序），底层是使用TreeMap来实现的")])]),a._v(" "),t("p",[a._v("Map：此接口实现的Key到Value的映射，一个Map中不能包含相同的Key，每个Key只能映射一个Value")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("HashTable：实现了一个Key-Value的哈希表，每一个非null元素都可作为Key或者Value，HashA")])]),a._v(" "),t("li",[t("p",[a._v("Table是同步的")])]),a._v(" "),t("li",[t("p",[a._v("HashMap：和HashTable的不同之处是，非同步的，且允许null元素的存在")])])]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"list问题汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list问题汇总"}},[a._v("#")]),a._v(" List问题汇总")]),a._v(" "),t("h3",{attrs:{id:"_1-arraylist和linkedlist的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-arraylist和linkedlist的区别"}},[a._v("#")]),a._v(" 1. ArrayList和LinkedList的区别")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("线程安全：")]),a._v(" ArrayList和LinkedList都是不同步的，不保证线程安全；")]),a._v(" "),t("li",[t("strong",[a._v("底层实现：")]),a._v(" ArrayList底层是用Object动态数组实现的，LinkedList是用双向链表实现的")]),a._v(" "),t("li",[t("strong",[a._v("扩容问题：")]),a._v(" ArrayList默认长度是10，使用1.5倍数组拷贝扩容；LinkedList链表实现，不存在扩容问题")]),a._v(" "),t("li",[t("strong",[a._v("插入删除：")]),a._v(" ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。指定位置插入需要将后面的元素挪后，删除时要往前覆盖，插入删除效率低下；LinkedList删除元素时间复杂度不受元素位置的影响，更换节点指向即可，插入删除效率高")]),a._v(" "),t("li",[t("strong",[a._v("查询访问：")]),a._v(" ArrayList是数组实现，支持任意位置元素访问，查询高效；LinkedList是链表实现，查询需要重头遍历链表，查询低下")]),a._v(" "),t("li",[t("strong",[a._v("内存空间占用：")]),a._v(" ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）")])]),a._v(" "),t("h3",{attrs:{id:"_2-arraylist和vector的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-arraylist和vector的区别"}},[a._v("#")]),a._v(" 2. ArrayList和Vector的区别")]),a._v(" "),t("p",[t("strong",[a._v("【相同点】")])]),a._v(" "),t("ul",[t("li",[a._v("底层都使用数组实现")]),a._v(" "),t("li",[a._v("功能相同，实现增删改查等操作的方法相似")]),a._v(" "),t("li",[a._v("长度可变的数组结构")])]),a._v(" "),t("p",[t("strong",[a._v("【不同点】")])]),a._v(" "),t("ul",[t("li",[a._v("Vector是早期JDK1.0 版本提供，ArrayList是JDK1.2 新版本替代Vector的")]),a._v(" "),t("li",[a._v("Vector 的方法都是同步的，线程安全；ArrayList非线程安全，异步操作，但性能比Vector好")]),a._v(" "),t("li",[a._v("默认初始化容量都是10，Vector 扩容默认会翻倍，可指定扩容的大小；ArrayList默认大小是10，1.5倍扩容机制")])]),a._v(" "),t("h3",{attrs:{id:"_3-arraylist扩容机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-arraylist扩容机制"}},[a._v("#")]),a._v(" 3. ArrayList扩容机制")]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"set问题汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set问题汇总"}},[a._v("#")]),a._v(" Set问题汇总")]),a._v(" "),t("h3",{attrs:{id:"_1-hashset如何检查重复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-hashset如何检查重复"}},[a._v("#")]),a._v(" 1. HashSet如何检查重复")]),a._v(" "),t("blockquote",[t("p",[a._v("HashSet不允许插入重复元素，会对插入的元素进行排序")])]),a._v(" "),t("ul",[t("li",[a._v("hash值相同，调用equals比较\n"),t("ul",[t("li",[a._v("equals比较相同，元素重复，不能插入")]),a._v(" "),t("li",[a._v("equals比较不同，元素不存在，可以插入")])])]),a._v(" "),t("li",[a._v("hash值不同，元素不存在，可以插入")])]),a._v(" "),t("h3",{attrs:{id:"_2-set集合与map集合的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-set集合与map集合的关系"}},[a._v("#")]),a._v(" 2. Set集合与Map集合的关系")]),a._v(" "),t("p",[a._v("HashSet的底层是基于HashMap实现的，TreeSet的底层是基于TreeMap实现的，Set集合的元素是Map集合中的"),t("code",[a._v("value")]),a._v("。")]),a._v(" "),t("ul",[t("li",[a._v("Set集合中存放的数据不允许重复")]),a._v(" "),t("li",[a._v("Map集合的数据是"),t("code",[a._v("key-value")]),a._v("的形式")])]),a._v(" "),t("h3",{attrs:{id:"_3-hashcode-equals方法关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-hashcode-equals方法关系"}},[a._v("#")]),a._v(" 3. hashCode，equals方法关系")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("hashCode")]),a._v("相同，则"),t("code",[a._v("equals")]),a._v("不一定相同，会存在哈希冲突")]),a._v(" "),t("li",[t("code",[a._v("equals")]),a._v("相同，"),t("code",[a._v("hashCode")]),a._v("则一定相同")]),a._v(" "),t("li",[a._v("equals方法被覆写过，则hashCode方法也必须被覆写")])]),a._v(" "),t("h3",{attrs:{id:"_4-treeset怎么实现的-treemap用的什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-treeset怎么实现的-treemap用的什么"}},[a._v("#")]),a._v(" 4. TreeSet怎么实现的？TreeMap用的什么")]),a._v(" "),t("p",[a._v("TreeSet基于TreeMap实现，TreeMap基于红黑树实现。TreeSet内部维持了—个简化版的TreeMap，存放的元素就是TreeMap中的"),t("code",[a._v("key")]),a._v("，会对元素排序且不允许重复。")]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"map问题汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map问题汇总"}},[a._v("#")]),a._v(" Map问题汇总")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210617195643.png",alt:""}})]),a._v(" "),t("h3",{attrs:{id:"_1-hashmap-和-hashtable的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-hashmap-和-hashtable的区别"}},[a._v("#")]),a._v(" 1. HashMap 和 Hashtable的区别")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("线程安全：")]),a._v(" HashMap是线程不安全的，Hashtable是线程安全的。Hashtable的方法都是同步的"),t("code",[a._v("synchronized")]),a._v("修饰（不建议使用，用ConcurrentHashMap替代）")]),a._v(" "),t("li",[t("strong",[a._v("效率：")]),a._v(" 因为线程安全的问题，HashMap 要比 HashTable 效率高。Hashtable基本被淘汰（ConcurrentHashMap替代），不要在代码中使用它；")]),a._v(" "),t("li",[t("strong",[a._v("null-key，null-value：")]),a._v(" HashMap允许存放null-"),t("code",[a._v("key")]),a._v("，null-"),t("code",[a._v("value")]),a._v("（null-"),t("code",[a._v("key")]),a._v("只允许存放一次）；Hashtable中put进的键值只要有一个 null，直接抛出 NullPointerException")]),a._v(" "),t("li",[t("strong",[a._v("初始容量和扩容 ：")]),a._v(" ①Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1； ①HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍（HashMap 总是使用2的幂作为哈希表的大小）")]),a._v(" "),t("li",[t("strong",[a._v("底层数据结构：")]),a._v(" JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。")])]),a._v(" "),t("h3",{attrs:{id:"_2-hashmap-和-hashset区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-hashmap-和-hashset区别"}},[a._v("#")]),a._v(" 2. HashMap 和 HashSet区别")]),a._v(" "),t("p",[a._v("HashSet 底层就是基于 HashMap 实现的。")]),a._v(" "),t("p",[a._v("【HashSet源码】")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("transient")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("E")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" map"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Dummy value to associate with an Object in the backing Map")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("PRESENT")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * Constructs a new, empty set; the backing <tt>HashMap</tt> instance has\n * default initial capacity (16) and load factor (0.75).\n */")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashSet")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    map "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("p",[a._v("我们可以看到，在初始化map时，其实就是使用了HashMap")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("HashMap")]),a._v(" "),t("th",[a._v("HashSet")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("实现了Map接口")]),a._v(" "),t("td",[a._v("实现Set接口")])]),a._v(" "),t("tr",[t("td",[a._v("存储键值对")]),a._v(" "),t("td",[a._v("仅存储对象")])]),a._v(" "),t("tr",[t("td",[a._v("调用 "),t("code",[a._v("put()")]),a._v("向map中添加元素")]),a._v(" "),t("td",[a._v("调用 "),t("code",[a._v("add()")]),a._v("方法向Set中添加元素")])]),a._v(" "),t("tr",[t("td",[a._v("HashMap使用键（Key）计算hashCode")]),a._v(" "),t("td",[a._v("HashSet使用成员对象来计算hashCode值，对于两个对象来说hashCode可能相同，所以equals()方法用来判断对象的相等性")])])])]),a._v(" "),t("h3",{attrs:{id:"_3-concurrenthashmap-和-hashtable-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-concurrenthashmap-和-hashtable-的区别"}},[a._v("#")]),a._v(" 3. ConcurrentHashMap 和 Hashtable 的区别")]),a._v(" "),t("h3",{attrs:{id:"_4-说说常见的hash算法-解决hash冲突的方式有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-说说常见的hash算法-解决hash冲突的方式有哪些"}},[a._v("#")]),a._v(" 4. 说说常见的hash算法,解决hash冲突的方式有哪些")]),a._v(" "),t("p",[a._v("目前流行的 Hash 算法包括 MD5、SHA-1 和 SHA-2")]),a._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_32534441/article/details/89669106",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[a._v("Hash算法总结")]),t("OutboundLink")],1)])]),a._v(" "),t("p",[a._v("解决hash冲突的方式有哪些")]),a._v(" "),t("ul",[t("li",[a._v("拉链法")]),a._v(" "),t("li",[a._v("开放地址法")]),a._v(" "),t("li",[a._v("再散列法")])]),a._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_32595453/article/details/80660676",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[a._v("解决哈希冲突的三种方法（拉链法、开放地址法、再散列法）")]),t("OutboundLink")],1)])]),a._v(" "),t("h3",{attrs:{id:"list、map、set-三个接口-存取元素时-各有什么特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list、map、set-三个接口-存取元素时-各有什么特点"}},[a._v("#")]),a._v(" List、Map、Set 三个接口，存取元素时，各有什么特点")]),a._v(" "),t("ul",[t("li",[a._v("List 以索引来存取元素，元素可重复")]),a._v(" "),t("li",[a._v("Set 不能存放重复元素")]),a._v(" "),t("li",[a._v("Map 保存键值对映射，映射关系可以一对一、多对一")]),a._v(" "),t("li",[a._v("List 有基于数组和链表实现两种方式")]),a._v(" "),t("li",[a._v("Set、Map 容器有基于哈希存储和红黑树两种方式实现")]),a._v(" "),t("li",[a._v("Set 基于 Map 实现，Set 里的元素值就是 Map 里 key")])])])}),[],!1,null,null,null);t.default=r.exports}}]);