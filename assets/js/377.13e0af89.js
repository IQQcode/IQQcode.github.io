(window.webpackJsonp=window.webpackJsonp||[]).push([[377],{703:function(t,s,a){"use strict";a.r(s);var n=a(3),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("参考阅读🍳"),s("a",{attrs:{href:"http://blog.itpub.net/31556438/viewspace-2662580/",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL是怎么保证数据一致性的"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"_1-mvcc是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvcc是什么"}},[t._v("#")]),t._v(" 1. MVCC是什么")]),t._v(" "),s("p",[t._v("MVCC: Multiversion Concurrency Control，翻译为"),s("strong",[t._v("多版本并发控制")]),t._v("，其目标就是为了"),s("strong",[t._v("提高数据库在高并发场景下的性能")])]),t._v(" "),s("p",[s("strong",[t._v("【原理】：")])]),t._v(" "),s("p",[t._v("简单来说就是保存数据的历史版本，通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。")]),t._v(" "),s("p",[s("strong",[t._v("MVCC最大的优势：读不加锁，读写不冲突。在读多写少的场景下极大的增加了系统的并发性能")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("行级锁的变种，减少加锁带来的开销（类比CAS）")])]),t._v(" "),s("li",[s("p",[t._v("适用于读已提交、可重复读两个事务场景，解决不可重复读和幻读问题，MVCC 机制取代行锁，降低系统开销")])])]),t._v(" "),s("h2",{attrs:{id:"_2-mvcc解决什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-mvcc解决什么问题"}},[t._v("#")]),t._v(" 2. MVCC解决什么问题")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("读写之间阻塞的问题")]),t._v("。通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。")]),t._v(" "),s("li",[s("strong",[t._v("降低了死锁的概率")]),t._v("。这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。")]),t._v(" "),s("li",[s("strong",[t._v("解决了一致性读的问题")]),t._v("。当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果")])]),t._v(" "),s("h3",{attrs:{id:"什么是快照读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是快照读"}},[t._v("#")]),t._v(" 什么是快照读")]),t._v(" "),s("p",[t._v("快照读，读取的是"),s("strong",[t._v("快照数据")]),t._v("，不加锁的简单 Select 都属于快照读.")]),t._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("SELECT * FROM player WHERE "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"什么是当前读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是当前读"}},[t._v("#")]),t._v(" 什么是当前读")]),t._v(" "),s("p",[t._v("当前读就是读的是"),s("strong",[t._v("最新数据")]),t._v(",而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。")]),t._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("SELECT * FROM player LOCK IN SHARE MODE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nSELECT FROM player FOR UPDATE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nINSERT INTO player values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n\nDELETE FROM player WHERE "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n\nUPDATE player SET "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h2",{attrs:{id:"_3-innodb-的-mvcc实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-innodb-的-mvcc实现"}},[t._v("#")]),t._v(" 3. InnoDB 的 MVCC实现")]),t._v(" "),s("p",[s("strong",[t._v("事务版本号 + 行记录中的隐藏列  + Undo Log")])]),t._v(" "),s("h3",{attrs:{id:"事务版本号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务版本号"}},[t._v("#")]),t._v(" 事务版本号")]),t._v(" "),s("p",[t._v("每开启一个日志，都会从数据库中获得一个事务ID（也称为事务版本号），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的时间顺序。")]),t._v(" "),s("h3",{attrs:{id:"行记录的隐藏列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行记录的隐藏列"}},[t._v("#")]),t._v(" 行记录的隐藏列")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232826.png",alt:"image-20201007181210245"}})]),t._v(" "),s("ol",[s("li",[s("code",[t._v("row_id")]),t._v(" ：隐藏的行 ID ，用来生成默认的聚集索引。如果创建数据表时没指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引")]),t._v(" "),s("li",[s("code",[t._v("trx_id")]),t._v("：数据事务 ID ，每次处理加一")]),t._v(" "),s("li",[s("code",[t._v("roll_ptr")]),t._v("：回滚指针，指向这个记录的 Undo Log 信息")])]),t._v(" "),s("h3",{attrs:{id:"undo-log"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[t._v("#")]),t._v(" Undo Log")]),t._v(" "),s("p",[t._v("InnoDB 将行记录快照保存在 Undo Log 里")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-later/20210626232830.png",alt:"650"}})]),t._v(" "),s("p",[t._v("数据行通过快照记录都通过链表的结构的串联了起来，每个快照都保存了 trx_id 事务ID，如果要找到历史快照，就可以通过遍历回滚指针的方式进行查找")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("【参考文章】"),s("a",{attrs:{href:"https://seven.geekfun.club/article/16",target:"_blank",rel:"noopener noreferrer"}},[t._v("MVCC机制总结"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);